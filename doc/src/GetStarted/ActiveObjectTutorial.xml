<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ActiveObjectTutorial"><info><title xml:id="ActiveObjectTutorial_18">Active Object Tutorial</title></info>

	<indexterm>
		<primary>Tutorial</primary>
	</indexterm>
	<indexterm>
		<primary>Active Object</primary>
		<secondary>Tutorial</secondary>
	</indexterm>

<para>In this chapter, we present a step by step introduction to
  programming with ProActive.</para>

  <para>The program that we will develop is a remote computation and monitoring agent. As we
  progress through the example, we
  will increase the complexity of the agent by using different features of ProActive.</para>

  <itemizedlist>
    <listitem>
      <para>In part one, we will code a 'client-server' application, the server
      being an active object that acts as a monitoring agent.</para>
    </listitem>

    <listitem>
      <para>In part two, we will see how we can control the activity of an active
      object.</para>
    </listitem>
 <listitem>
      <para>In part four, this exercise will explain message synchronization and
      synchronous and asynchronous method calls using a monitoring agent that makes chained calls.</para>
    </listitem>

    <listitem>
      <para>In part five, we will add mobility to this active object and make the agent migrate
      to another computer and report on the status of the JVM on the machine.</para>
    </listitem>
    <listitem>
      <para>In part six, we will show how to use ProActive groups to monitor several machines
      at the same time.</para>
    </listitem>
	<listitem>
		<para>In part seven, we will show how to expose an active object as a web service. </para>
	</listitem>

   <listitem><para>
		The next parts aim at showing how we can transform a sequential primality test
		into a distributed one. In this parts, we will also use the ProActive Master-Worker API.
   </para></listitem>
  </itemizedlist>
<!--	<para>-->
<!--		All the exercises in this chapter are available as an Eclipse workspace. -->
<!--		The Eclipse environment is set up to run each exercises as soon as -->
<!--		the needed code is inserted. The tasks needed for the examples to run properly are annotated with-->
<!--      <emphasis role="bold">//TODO</emphasis> tags and thus are shown up under the Eclipse tasks list.-->
<!--	</para>-->
   <para>
      In order to get the tutorials, that is to say, code sources with missing lines, go to the <literal>compile/</literal> directory
      and type <literal>build tutorials</literal>. This command will create a new directory in the ProActive home directory, called
      <literal>tutorials</literal>. This directory will be composed of four directories:
   </para>
   <itemizedlist>
      <listitem>
         <para><literal>src</literal> - source directory. You will find in this directory all sources to fill in.</para>
      </listitem>
      <listitem>
         <para><literal>compile</literal> - compilation directory. In this directory, you will be able to compile your code.
         Type <literal>build</literal> to know all the available targets. Normally, you will see one target per tutorial example.
         Targets will be described after each example throughout this chapter.</para>
      </listitem>
      <listitem>
         <para><literal>scripts</literal> - launch scripts directory. You will find in this directory all scripts to launch your compiled code.
         Scripts will be described after each example throughout this chapter.</para>
      </listitem>
      <listitem>
         <para><literal>dist</literal> - library directory. You will find in this directory all libraries needed to compile your code.
         Normally, you will not have to deal with this directory.</para>
      </listitem>
   </itemizedlist>

	<para> To further learn what is needed for the
		running ProActive applications, please refer to <xref linkend="Installation"/>.
	</para>

	<section xml:id="SimpleCMA"><info><title>Simple Computation And Monitoring Agent</title></info>

	<indexterm>
		<primary>Tutorial</primary>
		<secondary>Simple monitoring agent</secondary>
	</indexterm>
	<para>
		Welcome to your first ProActive program! This is one of the simplest applications that can be
		written using ProActive. We will create an active object locally and get the state of
		the JVM through it. Our application is composed of three classes with a client-server structure.
	</para>
		<para>
		The example illustrates the creation of an active object from the
		<literal>CMAgent</literal> class that will be
		used by the <literal>Main</literal> class to retrieve the JVM state
		 for a machine and print it to the standard output.
		The <literal>Main</literal> class corresponds to the client, and is
		 only a container for the <literal>main()</literal> method, while
		the <literal>CMAgent</literal> class corresponds to the server and
		 its instance is an active object which provides a <literal>getCurrentState()</literal>
		method as a remote service.
	</para>
	<para>
		To safely use the <literal>CMAgent</literal> class as an active object,
		we have to meet three requirements:
	</para>
		<itemizedlist>
			<listitem><para><emphasis role="bold">no direct access to field variables</emphasis> - If
							<literal>public</literal> variables are used, then the stub class generated from
							the original class may become decoupled from the original class. If a change is
							affected on the public field variable in the stub instance, the change will not be
							 propagated to the class instance from which the stub was generated. The safe
							 way to change variables is to set them as <literal>private</literal> and access
							 them through <literal>public getter/setter methods</literal>.</para></listitem>

			<listitem>
			<para><emphasis role="bold">provide a no-argument and preferably an empty constructor</emphasis> - A
							no-argument constructor is necessary to create the stub class needed for communication.
							A stub cannot be created if there are only constructors with arguments since the
							stub is only meant to abstract the communication from the active objects.

							If there is no constructor defined, the Java compiler
							will automatically create a no-argument constructor that initializes all instance variables
							to the default value. However, if there is an already defined constructor with arguments
							then no default no-argument constructor will be created by the compiler. In that case,
							the definition of a no-argument constructor is mandatory for stub creation. The safest way is
							to always define a no-argument constructor.
							Also, the constructor should be empty so that on stub creation no
							initialization is done on the stub.
						</para>
			</listitem>
			<listitem><para><emphasis role="bold">provide remote functionalities as public methods with return types that can be subclassed and are serializable</emphasis> - Since
			the stub is created through inheritance, the only methods it can use for communication are
			the inherited public methods from the superclass. The return types of the methods have to be
			 subclassable and therefore not final. ProActive provides several wrappers for Java types
			 that are final.The example uses the <literal>StringWrapper</literal> class in order to provide a wrapper for the
			final <literal>String</literal> class. Since ProActive uses a proxy mechanism and
			 the <literal>String</literal> class is final, it is not
			possible to subclass a String and to perform asynchronous calls.
			ProActive provides several wrappers for final classes: <literal>StringWrapper, BooleanWrapper,
			IntWrapper, DoubleWrapper</literal> and <literal>FloatWrapper</literal>.
			 These have to be used in
			replacement of <literal>String, Boolean, Integer, Double</literal> and <literal>Float</literal>
			in classes which will be active objects. If you do not use wrappers, method calls will be synchronous.
			In our case, the return type is <literal>State</literal> which is not final.
			</para>


			</listitem>
		</itemizedlist>

	  <section xml:id="ClassesUsed_10"><info><title>Classes Used</title></info>

		<itemizedlist><info><title xml:id="ProActive_3">ProActive</title></info>

			<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
		</itemizedlist>
		<itemizedlist><info><title xml:id="Other_4">Other</title></info>

				<listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can
				be sent across the network    </para></listitem>
				<listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
				<listitem><para><literal>java.net.InetAddress</literal> - used to get the address of the host where the active object is running on </para></listitem>
				<listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
				<listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>
		</section>
	<section xml:id="CMAArchitectureandSkeletonCode_4"><info><title>CMA Architecture and Skeleton Code </title></info>

	<para>For our Monitoring agent, we use three classes. The first two classes are regular Java objects.
	The first class is <literal>State</literal> which we use to get some information on the JVM the
	object is located on. This object will be use as return value for the <literal>getCurrentState()</literal>
	method in the <literal>CMAgent</literal> class.
	</para>

	<programlisting language="java"><textobject><textdata fileref="automatic_snippets/state_full.snip"/></textobject></programlisting>

	<para>
		The Monitoring agent class is a regular Java class with only one method:
	</para>
	 <programlisting language="java"><textobject><textdata fileref="automatic_snippets/fullCMA.snip"/></textobject></programlisting>

	<para>
	 For this simple exercise, we only need to add ProActive code in the Main class
	 where we instantiate the active object.
   </para>

	<programlisting language="java"><textobject><textdata fileref="automatic_snippets/simple_CMA_skeleton.snip"/></textobject></programlisting>

	</section>
	<section xml:id="ProposedWork_3"><info><title>Proposed Work</title></info>

		<para>
			You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/simple/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/simple/</literal>.
		</para>
	<orderedlist>
			<listitem><para>Create an active object using the <literal>org.objectweb.proactive.api.PAActiveObject.newActive(...)</literal>
				static method.</para></listitem>
			<listitem><para>Call the  <literal>getCurrentState()</literal> method and display the results.</para></listitem>
			<listitem><para>Since the active object has a never ending thread we need to make an explicit call in order
			to stop it. Use <literal>PAActiveObject.terminateActiveObject(...)</literal> to stop the
			active object and use the <literal>PALifeCycle.exitSuccess()</literal> method to terminate the application.</para>
			</listitem>
			<listitem><para>
				Remove the <literal>Serializable</literal> from the class <literal>State</literal> and explain the results when running the example.
				</para>
			</listitem>
		</orderedlist>
      <para>
         Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.simple</literal> to compile your code.
         Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>simpleCMA.[sh|bat]</literal> script
         to execute your code.
      </para>
	</section>

	<section xml:id="SolutionsandFullCode_5"><info><title>Solutions and Full Code </title></info>


	<orderedlist>
      <listitem>
		<para>We will now show how to create the server object. For now, we want the
		<literal> CMAgent</literal> active object
		 to be created on the current Node (we will see later how to distribute the program). To create an instance of
		  a remotely accessible object, we must use the <literal>PAActiveObject.newActive(...)</literal> static method. We pass
		  as an argument the name of the class to be instantiated and arguments for the constructor of the class.
		  In our case, <literal>CMAgent</literal> does not need any arguments for the constructor and therefore we use <literal>null</literal>.
		  <programlisting language="java"><textobject><textdata fileref="automatic_snippets/CMA_instantiation.snip"/></textobject></programlisting>
		</para>
      </listitem>

      <listitem>
	<para>
		Invoking a method on a remote active object is transparent and is similar
		to  invoking a method on
		a local object of the same type. The user does not have to deal with catching exceptions
		related to the remote communication. The only modification brought to the code by ProActive
		is during the active objects creation. All the rest of the code can remain unmodified,
		fostering software reuse. </para>

		<para>
			To invoke the <literal>getCurrentState()</literal> method and display the result, we execute:
		</para>

      <programlisting language="java"><textobject><textdata fileref="automatic_snippets/CMA_call.snip"/></textobject></programlisting>
   </listitem>

   <listitem>
	<para>To stop the active object, we call the <literal> PAActiveObject.terminateActiveObject(ao, false)</literal> method. The
	<literal>false</literal> argument is used in order to call the terminate method as a regular request. If the
	argument was <literal>true</literal>, the method call would be served as an immediate service (executed as soon as the
	current executing request is completed regardless of how many other requests might be waiting)
	and synchronously (the caller thread blocks until it receives the results). </para>

		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/CMA_terminate_call.snip"/></textobject></programlisting>
	</listitem>

   <listitem>
	<para>Passive objects in ProActive are always passed by deep copy when returned as a method results.
	If the object State does not implement the <literal>Serializable</literal> interface, ProActive will not be able
	to make a deep copy of the object and will throw an exception.</para>
	</listitem>
   </orderedlist>

	<para> The full code of the <literal>Main</literal> class is the following:</para>
	<programlisting language="java"><textobject><textdata fileref="automatic_snippets/CMA_Main.snip"/></textobject></programlisting>

	</section>
	</section>

  <section xml:id="Active_Object_LifeCycle"><info><title>Active Objects Lifecycle: Using InitActive, RunActive and EndActive</title></info>

	<indexterm>
		<primary>Tutorial</primary>
		<secondary>Active Objects Lifecycle</secondary>
	</indexterm>

    <para>Active objects, as their name indicates, have an activity of their
    own (an internal thread). By default, the active object steps through
    the constructor, the <literal>initActivity</literal>, the <literal>runActivity</literal>,
     and when the <literal>terminate</literal> method is called on
    the <literal>Body</literal> of the active object through the <literal>endActivity</literal> method.
    It is possible to control the initialization, running, and ending phase of this
    thread by implementing three interfaces: <literal>InitActive</literal>, <literal>
    RunActive</literal>,and <literal>EndActive</literal>.These interfaces define respectively the
    <literal>initActivity</literal>, <literal>runActivity</literal> and <literal>endActivity</literal>
    methods. One of the reasons for using <literal>initActivity</literal>
    method is the presence of the empty constructor in an active object. The <literal>initActivity</literal>
    method is automatically called on the creation of an active object in order to set up the
    object without using the constructor. The <literal>runActivity</literal> method allows the user
    to control the active object request queue. By implementing the <literal>EndActive</literal> interface, it is also possible to
    clean up before the active object thread is stopped.</para>


    <para>The following example will help you to understand how and when you
    can initialize and clean the activity. The example will implement the <literal>InitActive</literal>, <literal>RunActive</literal>,
     and
    <literal>EndActive</literal> interfaces. However <literal>RunActive</literal> has a more complex structure than
    it is presented here. To understand how to use <literal>EndActive</literal>
    <literal>RunActive</literal> interface, please refer to
	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../ReferenceManual/multiple_html/ActiveObjectCreation.html">Active Objects: Creation And Advanced Concepts</link>.
	</para>

	  <section xml:id="ClassesUsed_1"><info><title>Classes Used</title></info>


		<itemizedlist><info><title xml:id="Newclassesused_1">New classes used</title></info>
			<listitem><para><literal>org.objectweb.proactive.Body</literal> - used to access the body of the active object</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.Service</literal> - used to access the queue of the active object</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.InitActive</literal> - used to define the <literal>initActivity(Body body)</literal> method, which is run at active object initialization</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.EndActive</literal> - used to define the <literal>endActivity(Body body)</literal> method, which is run at active object destruction</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.RunActive</literal> - used to define the <literal>runActivity(Body body)</literal> method, which manages the queue of requests</para></listitem>
			<listitem><para><literal> org.objectweb.proactive.core.util.wrapper.LongWrapper</literal> - used to wrap the <literal>Long</literal> return type</para></listitem>
		</itemizedlist>

		<itemizedlist><info><title xml:id="Previouslyusedclasses_1">Previously used classes</title></info>

			<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
			<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
			<listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can
				be sent across the network  </para></listitem>
				<listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
				<listitem><para><literal>java.net.InetAddress</literal> - used to get the address of host where the active object is running on </para></listitem>
				<listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
				<listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>

	</section>

    <section xml:id="InitializedCMAArchitectureandSkeletonCode_5"><info><title>Initialized CMA Architecture and Skeleton Code</title></info>


      <para>The <literal>CMAgentInitialized</literal> class extends the
      <literal> CMAgent </literal>class from the previous example, and implements
      the interfaces <literal>InitActive</literal> and <literal>EndActive</literal>.
      It acts as a server for the <literal>Main</literal> class.</para>

    <para>
	To implement the application we will create a class that inherits from the
	<literal>CMAgent</literal> class and implements the <literal>InitActive</literal>, <literal>RunActive</literal>, and <literal>EndActive</literal>
	interfaces.
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/init_CMA_skeleton.snip"/></textobject></programlisting>
    </para>
    <para>
	By default an active object has a never-ending thread that should be stopped when the object is
	not needed anymore. The method <literal>terminate()</literal> serves the purpose of destroying the
	object. However, if an explicit call to terminate the object is not made, ProActive has its own
	distributed garbage collection system that is able to decide when an active object can be destroyed.
    </para>
    <para>
	The <literal>Main</literal> is similar to the one in the previous example.
	We will change the object created from <literal>CMAAgent</literal> to
	<literal>CMAAgentInitialized</literal> and also we will call the <literal>terminate() </literal> method to
	destroy the object.
    </para>

    </section>

	<section xml:id="ProposedWork_4"><info><title>Proposed Work</title></info>

		<para>
			You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/initialized/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/initialized/</literal>.
		</para>
		<orderedlist>
			<listitem><para>Use <literal>initActivity(Body body)</literal> to print information
			about the start location of the active object and record the start time.</para></listitem>
			<listitem><para>Use <literal>endActivity(Body body)</literal> to print information about
			 the stop location of the active object, calculate the running time,
			 and print the number of requests served.</para></listitem>

			<listitem><para>Calculate the last request duration
			 and count the requests using <literal>org.objectweb.proactive.Service.waitForRequest()</literal>
			and <literal>org.objectweb.proactive.Service.serveOldest()</literal> </para></listitem>
			<listitem><para>Use <literal>org.objectweb.proactive.core.util.wrapper.LongWrapper</literal>
			to return a wrapped <literal>Long</literal> value.</para></listitem>
		</orderedlist>

      <para>
         Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.initialized</literal> to compile your code.
         Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>initializedCMA.[sh|bat]</literal> script
         to execute your code.
      </para>
	</section>

    <section xml:id="SolutionandFullCode_1"><info><title>Solution and Full Code</title></info>

	<para>
	We only need to extend the <literal>CMAgent</literal> class and implement the
	interfaces. In <literal>initActivity(Body body)</literal>, we use <literal>body.getName()</literal>
	to get the name of the active object and <literal>body.getNodeUrl()</literal> to get the location.
	In  <literal>endActivity(Body body)</literal>, we also use <literal>body.getNodeUrl()</literal> to get the location.
	</para>
	<programlisting language="java"><textobject><textdata fileref="automatic_snippets/cma_init_full.snip"/></textobject></programlisting>
    </section>
  </section>
	<section xml:id="RemoteMonitoringAgent_18"><info><title>Remote Monitoring Agent</title></info>

		<indexterm>
			<primary>Tutorial</primary>
			<secondary>Remote Monitoring Agent</secondary>
		</indexterm>

			<para>
				In this part of the tutorial, we will see how to start a monitoring agent using the deployment methods.
            In the previous example, the application were deployed inside
            the same JVM. This section will focus on showing how to deploy
            the application on different nodes using deployment
            descriptors.
				To be able to deploy on remote machines, we just have to
            use the deployment file, add a method that tells
            ProActive to activate the nodes used and tell the active object to start on the remote node.
            This section does not aim at explaining how to write deployment files but rather at describing how to use them.
            If you want more information on GCM deployment, please refer to
			<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../ReferenceManual/multiple_html/GCMDeployment.html">ProActive Grid Component Model Deployment</link>
			Normally,
            only GCM concepts as well as the provided examples will be useful to successful achieve this tutorial.
            Anyway, launch scripts use a deployment descriptor which will use local JVMs.
			</para>
		<section xml:id="ClassesUsed_3"><info><title>Classes Used</title></info>

		<itemizedlist><info><title xml:id="Newclasses_15">New classes</title></info>

			<listitem><para><literal> org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment</literal> - used to create a GCMApplication from an Application Descriptor</para> </listitem>
			<listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed </para> </listitem>
			<listitem><para><literal>org.objectweb.proactive.core.ProActiveException</literal> - used to catch exception </para> </listitem>
			<listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para> </listitem>
		</itemizedlist>
		<itemizedlist><info><title xml:id="Previouslyusedclasses_2">Previously used classes</title></info>

				<listitem><para><literal>org.objectweb.proactive.Body</literal> - used to access the body of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.PALifeCycle</literal> - controls the lifecycle of the ProActive application</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.Service</literal> - used to access the queue of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.InitActive</literal> - used for defining the <literal>initActivity(Body body)</literal> method, which is run at active object initialization</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.EndActive</literal> - used for defining the <literal>endActivity(Body body)</literal> method, which is run at active object destruction </para></listitem>
				<listitem><para><literal>org.objectweb.proactive.RunActive</literal> - used for defining the <literal>runActivity(Body body)</literal> method, which manages the queue of requests</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.util.wrapper.LongWrapper</literal> - used to wrap the <literal>Long</literal> return type</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
				<listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can be sent across the network  </para></listitem>
				<listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
				<listitem><para><literal>java.net.InetAddress</literal> - used to get the address of the host where the active object is running on </para></listitem>
				<listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
				<listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>


	</section>
	<section xml:id="DeployedCMAArchitectureandSkeletonCode_18"><info><title>Deployed CMA Architecture and Skeleton Code</title></info>


		<para>
			We will change the
			<literal>Main</literal>
			class to declare and load the deployment descriptors to be
			used. For this, we will use a
			<literal>deploy()</literal>
			method that returns a Virtual Node which has several nodes (as specified in the deployment file)
			that we can deploy on.
			First, the method creates an object representation
			of the deployment file, then activates all the nodes, and
			then returns the first available node. We also have to change the deployment descriptor files to fit our local
			settings.

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/deploy_CMA_skeleton.snip"/></textobject></programlisting>

		</para>
	</section>
		<section xml:id="ProposedWork_5"><info><title>Proposed Work</title></info>

         <para>
			You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/deployed/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/deployed/</literal>.
         </para>

			<orderedlist>
			<listitem><para>Create GCMApplication from the application descriptor file using <literal> PAGCMDeployment.loadApplicationDescriptor(String descriptor)</literal></para></listitem>
			<listitem><para>Start the deployment of all the virtual nodes using <literal>GCMApplication.startDeployment()</literal></para></listitem>
			<listitem><para>Wait for all virtual nodes to get ready using <literal>GCMApplication.waitReady()</literal></para></listitem>
			<listitem><para>Get a virtual node using <literal>GCMApplication.getVirtualNodes()</literal>. You can also use <literal>GCMApplication.getVirtualNode(String virtualNodeName)</literal>.
         Still, this latter method requires to know the name of the virtual node and so, it forces us to give the same virtual node id into every application descriptor we want to pass as argument.
         </para></listitem>
			<listitem><para>Return this virtual node</para></listitem>
			<listitem><para>Retrieve a virtual node using the previous <literal>deploy()</literal> method.</para></listitem>
			<listitem><para>Create the active object using a node from the virtual node</para></listitem>
			<listitem><para>Get the state from the active object</para></listitem>
			<listitem><para>Print this state</para></listitem>
			<listitem><para>Stop the active object</para></listitem>
			<listitem><para>Stop the virtual node using <literal>GCMApplication.kill()</literal></para></listitem>
			<listitem><para>Change the <literal>State</literal> class so that the initialization of variables takes place in the <literal>toString()</literal> method.
			 Run the deployed application again and explain the different results. Hint: try to deploy the application on a remote host.</para></listitem>
			</orderedlist>
         <para>
            Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.deployed</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>deployedCMA.[sh|bat]</literal> script
            to execute your code.
         </para>
		</section>

		<section xml:id="SolutionandFullCode_2"><info><title>Solution and Full Code</title></info>

      <para>In the <literal>deploy()</literal> method, we return the first virtual node found in the deployment descriptor: </para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/cma_deploy_method.snip"/></textobject></programlisting>

		<para>
		 The active object is created by using the first node on the virtual node:
		</para>

				<programlisting language="java"><textobject><textdata fileref="automatic_snippets/cma_deploy_object.snip"/></textobject></programlisting>

		<para>

			The full
			<literal>Main</literal>
			class:
		</para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/cma_deploy_full.snip"/></textobject></programlisting>


      <para>
         In order to answer to our last question, we follow the given hint. To do that, the simplest way is to remove the local host from the host list
         in the nodeProvider tag. In our case, the local host is <literal>kisscool</literal>. Try to do same thing and launch the application with
         the two different variable initializations.
      </para>
      <note>
         <para>
            the remote machine needs to have the <literal>rsh</literal>
			service running since we are using <literal>rsh</literal> deployment.
         </para>
      </note>
      <para>
         If you do not change the <literal>State</literal> class, you will get a display looking like the following one:
      </para>
      <screen>
         ======= [State at Wed May 27 14:45:05 CEST 2009 on paquito.inria.fr/138.96.218.106] =======
         Commited memory: 63111168 bytes
         Initial memory requested: 63961152 bytes
         Maximum memory available: 985530368 bytes
         Used memory: 7939936 bytes
         Operating System: Linux 2.6.23.1-21.fc7 i386
         Processors: 2
         Current live threads: 27
         Total started threads: 27
         Peak number of live threads: 27
         Current daemon threads: 21
         ===============================================================================
      </screen>
      <para>
         Whereas with the variable initializations done in the <literal>toString()</literal> method, you will get something like this:
      </para>
      <screen>
         ======= [State at Wed May 27 14:46:14 CEST 2009 on kisscool/138.96.218.126] =======
         Commited memory: 161021952 bytes
         Initial memory requested: 130110784 bytes
         Maximum memory available: 1034027008 bytes
         Used memory: 45900640 bytes
         Operating System: Linux 2.6.27.9-159.fc10.x86_64 i386
         Processors: 4
         Current live threads: 41
         Total started threads: 41
         Peak number of live threads: 41
         Current daemon threads: 37
         ===============================================================================
      </screen>
		<para>
         You can therefore realise that information returned in the second display are information about the local host but not about
         the host where the active object was running on. This is totally normal since when you call the <literal>toString()</literal>
         method, you will implicitly get the active object from the remote host and call this method next. So, if variable initializations
         are done in the <literal>toString()</literal> method, returned information will be information on the local host, whereas if variable
         initializations are done at the active object creation, returned information will be information on the host where the active object
         has been created that is to say, the remote host.
		</para>

	</section>

	  </section>
	<section xml:id="Agentsynchronization_18"><info><title>Agent synchronization</title></info>
		<indexterm>
			<primary>Tutorial</primary>
			<secondary>Agent Synchronisation</secondary>
		</indexterm>

		<para>
			In this example, we will use a chained call between agents deployed on several node in order to retrieve
			information about the nodes. We have several agents that know their previous and next neighbour.
			When an agent receives a request for a state returns its state and asks the its respective neighbour for the state.
			If it doesn't have a neighbour then it just returns its state. We will use this example to show how
			<literal> PAActiveObject.getStubOnThis()</literal> method call is employed. Since an active object is actually a composite of
			two objects, the method call <literal>PAActiveObject.getStubOnThis()</literal>
			is the equivalent of <literal>this</literal> in a regular java object. If we used <literal>this</literal>, we would get
			a reference to the passive object and not to the stub of the active object.
		</para>
		<section xml:id="ClassesUsed_4"><info><title>Classes Used</title></info>

			<para> There are no new classes used in this exercise. Instead we will show how to use
			the<literal>PAActiveObject.getStubOnThis()</literal> method.
			</para>
				<itemizedlist><info><title xml:id="Previouslyusedclasses_3">Previously used classes</title></info>

            <listitem><para><literal> org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment</literal> - used to create a GCMApplication from an Application Descriptor</para></listitem>
            <listitem> <para><literal>org.objectweb.proactive.core.ProActiveException</literal> - used to catch exception</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.core.node.Node</literal> - used to instantiate and control Node objects</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.Body</literal> - used to access the body of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.PALifeCycle</literal> - controls the lifecycle of the ProActive application</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.Service</literal> - used to access the queue of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.InitActive</literal> - used to define the <literal>initActivity(Body body)</literal> method, which is run at active object initialization</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.EndActive</literal> - used to define the <literal>endActivity(Body body)</literal> method, which is run at active object destruction </para></listitem>
				<listitem><para><literal>org.objectweb.proactive.RunActive</literal> - used to define the <literal>runActivity(Body body)</literal> method, which manages the queue of requests</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.util.wrapper.LongWrapper</literal> - used to wrap the <literal>Long</literal> return type</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
				<listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can be sent across the network  </para></listitem>
				<listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
				<listitem><para><literal>java.net.InetAddress</literal> - used to get the address of the active object is running on </para></listitem>
				<listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
				<listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>
		</section>
		<section xml:id="ArchitectureandSkeletonCode_6"><info><title>Architecture and Skeleton Code</title></info>

			<para>There are no new concepts present in the <literal>Main</literal> class.
			 We just create the active objects and make the method calls on one of the active objects.</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/synch_cma_main.snip"/></textobject></programlisting>

			 <para>
			 The agent class inherits from <literal>CMAgentInitialized</literal>:
			 </para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/synch_cma_skeleton.snip"/></textobject></programlisting>


		</section>
		<section xml:id="ProposedWork_6"><info><title>Proposed Work</title></info>

         <para>
			You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/synch/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/synch/</literal>.
			</para>

         <orderedlist>
			<listitem><para>Write the code for connecting to the previous neighbour</para></listitem>
			<listitem><para>Write the code for connecting to the next neighbour</para></listitem>
			<listitem><para>Add and remove explicit synchronization between the agents when retrieving the states</para></listitem>
			</orderedlist>
         <para>
            Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.synch</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>synchCMA.[sh|bat]</literal> script
            to execute your code.
         </para>
		</section>
		<section xml:id="SolutionAndFullCode_1"><info><title>Solution And Full Code</title></info>

			<para>
			To pass a remote reference to the active object we are currently in, we use <literal>PAActiveObject.getStubOnThis()</literal>.
			A simple use of the <literal>this</literal> keyword will return a reference to the passive object components of the
			active object and not a reference to the stub.
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/synch_getstub_usage.snip"/></textobject></programlisting>
			<para>The full code for the <literal>CMAAgentChained</literal> class is: </para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/synch_cma_full.snip"/></textobject></programlisting>

			<para>
			In the previous example, we have some parts of the code that may trigger a <literal>wait-by-necessity</literal>. A <literal>wait-by-necessity</literal> happens when we try to use
			a future that has not been updated yet. When a future in this state is used, the thread trying to use the future blocks until the value of the future is updated.
			</para>

		</section>
	</section>

  <section xml:id="MonitoringSeveralComputersUsingMigration_18"><info><title>Monitoring Several Computers Using Migration</title></info>

	<indexterm>
		<primary>Tutorial</primary>
		<secondary>Monitoring Several Computers Using Migration</secondary>
	</indexterm>

       <para>Our next example deals with migrating the Monitoring Agent between
    remote nodes. We will start the monitoring agent on one machine and then move it
    to other machines and report on the state of each JMV on the machines.
    To do that, we will need to change the descriptor file to specify the
     nodes and the machines the nodes are mapped to. We also have to add a a method that enables us to
    tell the active object to migrate. </para>

	<para>
		An active object has to implement the Serializable interface (as it will be transferred
		through the network) in order to be able to migrate.
		For more information on the topic of object migration, check
		<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../ReferenceManual/multiple_html/Migration.html">Mobile Agents And Migration</link>.
		</para>

	<section xml:id="ClassesUsed_5"><info><title>Classes Used</title></info>

		<itemizedlist><info><title xml:id="Newclasses_11">New classes</title></info>

			<listitem><para><literal>org.objectweb.proactive.api.PAMobileAgent</literal> - used to tell the active object to migrate </para></listitem>
			<listitem><para><literal>org.objectweb.proactive.core.body.migration.MigrationException</literal>  - used to catch migration related exceptions</para></listitem>


		</itemizedlist>
		<itemizedlist><info><title xml:id="Previouslyusedclasses_4">Previously used classes</title></info>

         <listitem><para><literal> org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment</literal> - used to create a GCMApplication from an Application Descriptor</para></listitem>
         <listitem> <para><literal>org.objectweb.proactive.core.ProActiveException</literal> - used to catch exception</para></listitem>
         <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed</para></listitem>
         <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para></listitem>
			<listitem><para><literal> org.objectweb.proactive.core.node.Node</literal> - used to instantiate and control Node objects</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.Body</literal> - used to access the body of the active object</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.PALifeCycle</literal> - controls the lifecycle of the ProActive application</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.Service</literal> - used to access the queue of the active object</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.InitActive</literal> - used for defining the <literal>initActivity(Body body)</literal> method, which is run at active object initialization</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.EndActive</literal> - used for defining the <literal>endActivity(Body body)</literal> method, which is run at active object destruction </para></listitem>
         <listitem><para><literal>org.objectweb.proactive.RunActive</literal> - used for defining the <literal>runActivity(Body body)</literal> method, which manages the queue of requests</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.core.util.wrapper.LongWrapper</literal> - used to wrap the <literal>Long</literal> return type</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
         <listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
         <listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can be sent across the network  </para></listitem>
         <listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
         <listitem><para><literal>java.net.InetAddress</literal> - used to get the address of the active object is running on </para></listitem>
         <listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
         <listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>


	</section>


    <section xml:id="DesignofMigratableMonitoringAgentandSkeletonCode_18"><info><title>Design of Migratable Monitoring Agent and Skeleton Code</title></info>



      <para>We create a <literal>CMAgentMigrator</literal> class, that inherits from
      <literal>CMAInitialized</literal>.  This class will implement all the non-functional
      behavior concerning the migration, for which this example is created.
      </para>

      <para>The migration has to be initiated
      by the active object itself. We will have to write the migrate method in the code of
       CMAgentMigrator -
      i.e. a method that contains an explicit call to the migration primitive.
      </para>

      <para>CMAgentMigrator skeleton class:</para>
      <programlisting language="java"><textobject><textdata fileref="automatic_snippets/migrate_cma_skeleton.snip"/></textobject></programlisting>

		<para>In the <literal>Main</literal> class, we only have to change a few lines of code to migrate the agent. As you may notice
		there is more code for creating the textual menu than for controlling the agents.</para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/migrate_main_cma_skeleton.snip"/></textobject></programlisting>


	</section>

	<section xml:id="ProposedWork_7"><info><title>Proposed Work</title></info>

      <para>
      You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/migration/</literal>
      directory. Full code is also available into the directory
      <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/migration/</literal>.
      </para>

		<orderedlist>
			<listitem><para>Write the code for the migration method using <literal>org.objectweb.proactive.api.PAMobileAgent.migrateTo(Node URL)</literal></para></listitem>
			<listitem><para>Create the menu using the node URLs - <literal>org.objectweb.proactive.api.Node.getNodeInformation().getURL()</literal></para></listitem>
			<listitem><para>Migrate the node</para></listitem>
			<listitem><para>Get and print the state of the node</para></listitem>
         <listitem><para>Print the execution time of the last request</para></listitem>
         <listitem><para>Stop all the objects and JVM</para></listitem>
<!--			<listitem><para>Start the application and exit immediately (press 0). While is there a 1 request processed ?</para></listitem>-->
<!--			<listitem><para>Start the application migrate the agent once and then exit. Why are there 3 requests processed ?</para></listitem>-->
		</orderedlist>
      <para>
         Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.migration</literal> to compile your code.
         Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>migrateCMA.[sh|bat]</literal> script
         to execute your code.
      </para>
	</section>
    <section xml:id="SolutionandFullCode_4"><info><title>Solution and Full Code</title></info>

      <para>
         This first question is straightforward since you just have to call the <literal>PAMobileAgent.migrateTo</literal> method.
         The <literal>CMAgentMigrator</literal> class is therefore as follows:
      </para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/migrate_cma_full.snip"/></textobject></programlisting>
      <warning>
         <para>As it said in comments, codes after the <literal>migrateTo</literal> method will not be executed.</para>
      </warning>
      <para>
         Other questions are not more difficult and here is the <literal>CMAAgentMigrator</literal> class:
      </para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/migrate_main_cma_full.snip"/></textobject></programlisting>

    </section>
  </section>



	<section xml:id="GroupsofMonitoringAgents_18"><info><title>Groups of Monitoring Agents</title></info>

	<indexterm>
		<primary>Tutorial</primary>
		<secondary>Groups of Monitoring Agents</secondary>
	</indexterm>

		<para>
		In this part of the tutorial, we will show how to use groups of active objects.
		We will create several active objects that we add and remove from a group.
		The group will be used to retrieve the <literal>State</literal>
		object from all the active objects in the
		group.
		In order to ease the use of the group communication,
		ProActive provides a set of static methods in the <literal>PAGroup</literal>
		class and a set of methods in the <literal>Group</literal> interface.
		ProActive also provides typed group communication,
		meaning that only methods defined on classes or interfaces
		implemented by members of the group can be called.

      There are two ways to create groups of active objects: using the PAGroup.newGroup(...)  static method or using the PAGroup.newGroupInParallel(...) one.
      Once the group created, it is possible to turn it into active using the PAGroup.turnActiveGroup(...)  static method.
      Group creation takes several parameters similar to those of active object creation.
      To understand parameters that are not explained here, please refer to Chapter 9, Active Objects: Creation And Advanced Concepts
      as it contains a detailed explanation of every active object creation parameter.
		</para>
		<section xml:id="ClassesUsed_6"><info><title>Classes Used</title></info>

			<itemizedlist><info><title xml:id="NewClasses_1">New Classes</title></info>

				<listitem><para><literal>org.objectweb.proactive.api.PAGroup</literal> - used to create a group of active objects</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.group.Group</literal> - used to control the group of objects</para></listitem>
			</itemizedlist>

			<itemizedlist><info><title xml:id="Previouslyusedclasses_5">Previously used classes</title></info>

            <listitem><para><literal> org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment</literal> - used to create a object version of the deployment descriptor</para> </listitem>
            <listitem> <para><literal>org.objectweb.proactive.core.ProActiveException</literal> - used to handle ProActive exceptions</para> </listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.core.node.Node </literal> - used to instantiate and control Node objects</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.Body</literal> - used to access the body of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.PALifeCycle</literal> - controls the lifecycle of the ProActive application</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.Service</literal> - used to access the queue of the active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.InitActive</literal> - used for defining the <literal>initActivity(Body body)</literal> method, which is run at active object initialization</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.EndActive</literal> - used for defining the <literal>endActivity(Body body)</literal> method, which is run at active object destruction </para></listitem>
				<listitem><para><literal>org.objectweb.proactive.RunActive</literal> - used for defining the <literal>runActivity(Body body)</literal> method, which manages the queue of requests</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.util.wrapper.LongWrapper</literal> - used to wrap the <literal>Long</literal> return type</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>
				<listitem><para><literal>java.io.Serializable</literal> - used to make the <literal>State</literal> object serializable so it can be sent across the network  </para></listitem>
				<listitem><para><literal>java.lang.management.ManagementFactory</literal> - used to get various information about the machine the active object is running on </para></listitem>
				<listitem><para><literal>java.net.InetAddress</literal> - used to get the address of the active object is running on </para></listitem>
				<listitem><para><literal>java.net.UnknownHostException</literal>  - used to catch the exceptions that might be thrown when requesting host information </para></listitem>
				<listitem><para><literal>java.util.Date</literal> -  used to get the time for the requested state </para></listitem>
		</itemizedlist>
		</section>
		<section xml:id="ArchitectureandSkeletonCode_1"><info><title>Architecture and Skeleton Code</title></info>

			<para>
			In this example, we only need to modify the <literal>Main</literal> class
			to create the group of objects. To instantiate the active object, we will use the <literal>CMAgentInitialized</literal>
			class that we have defined previously.
			</para>
		<para>Main skeleton class:</para>
	<programlisting language="java"><textobject><textdata fileref="automatic_snippets/groups_cma_main_skeleton.snip"/></textobject></programlisting>
		</section>
		<section xml:id="ProposedWork_9"><info><title>Proposed Work</title></info>

         <para>
         You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/groups/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/groups/</literal>.
         </para>

			<orderedlist>
			<listitem><para>Create a new empty group using <literal>PAGroup.newGroup(..)</literal></para></listitem>
			<listitem><para>Create a collection of active objects with on object on each node</para></listitem>
			<listitem><para>Get a management representation of the monitors group using the <literal>Group</literal> interface</para></listitem>
			<listitem><para>Print the Node URL using <literal>PAActiveObject.getActiveObjectNodeUrl(...)</literal></para></listitem>
			<listitem><para>Use <literal>PAGroup.waitAndGetOneThenRemoveIt()</literal> to control the list of <literal>State </literal>futures</para></listitem>
			<listitem><para>Use the management representation to add or remove the agent (choice-1) to/from the group.</para></listitem>
			</orderedlist>

         <para>
            Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.groups</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>groups.[sh|bat]</literal> script
            to execute your code.
         </para>

		</section>
		<section xml:id="SolutionAndFullCode_2"><info><title>Solution And Full Code</title></info>

			<para>To create the group, we need to specify the type of the group. In our case, we use the
		previously defined <literal>CMAgentMigrator</literal>. We first create the group and then
		get a management representation of the group through the <literal>Group</literal> interface.
		The <literal>Group</literal> interface has the necessary methods for adding and removing members
		of the group.
		 </para>

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/groups_group_creation.snip"/></textobject></programlisting>

		<para>We use synchronization to wait for all the agents to send the states. As an agent
		returns a <literal>State</literal>, we remove it from the list of futures. </para>

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/groups_wbn.snip"/></textobject></programlisting>
		<para>
               To test if an agent is into the group and then to add or remove it, we use the same methods as for the classical containers, that is to say,
               the methods <literal>contains</literal>, <literal>add</literal> and <literal>remove</literal>:
            </para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/groups_add_remove.snip"/></textobject></programlisting>

		<para>The full <literal>Main </literal> method:</para>
		<programlisting language="java"><textobject><textdata fileref="automatic_snippets/groups_cma_full.snip"/></textobject></programlisting>



		</section>
	</section>

	<section xml:id="MonitoringAgentAsAWebService_18"><info><title>Monitoring Agent As A Web Service</title></info>

		<indexterm>
			<primary>Tutorial</primary>
			<secondary>Monitoring Agent As A Web Service</secondary>
		</indexterm>
		<para>
		In this example, we will show how to expose an active object as a web service.
		We will use the same monitoring agent as in the previous examples and
		expose it as a web service. You can expose it either to the local Jetty server or to
      a Tomcat server (or an other application server). For the latter, you first have to generate
      the <literal>proactive.war</literal> archive, using the command <literal>build proActiveWar</literal> into
      the <literal>compile</literal> directory and to put it in your application server.


		</para>
		<section xml:id="ClassesUsed_7"><info><title>Classes Used</title></info>

			<itemizedlist><info><title xml:id="NewClasses_2">New Classes</title></info>

				<listitem><para><literal>org.objectweb.proactive.extensions.webservices.AbstractWebServicesFactory</literal> - used to get a WebServicesFactory depending on the CXF framework</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.extensions.webservices.WebServicesFactory</literal> - used to get a WebServices corresponding to a specified url</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.extensions.webservices.WebServices</literal> - used to transform the active object into a web service</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.extensions.webservices.exceptions.WebServicesException</literal> - used to report web service exceptions</para></listitem>
			</itemizedlist>

			<itemizedlist><info><title xml:id="Previouslyusedclasses_6">Previously used classes</title></info>


				<listitem><para><literal>org.objectweb.proactive.api.PAActiveObject</literal> - used to create an instance of an active object</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.core.node.NodeException</literal> - used to catch the exceptions that the creation of the Node might throw</para></listitem>
				<listitem><para><literal>org.objectweb.proactive.ActiveObjectCreationException</literal> - used to catch the exceptions that the creation of the active object might throw </para></listitem>

			</itemizedlist>
		</section>
		<section xml:id="ArchitectureandSkeletonCode_2"><info><title>Architecture and Skeleton Code</title></info>

			<para>In this example, we extend <literal>CMAgentInitialized</literal>
			and create a <literal>CMAgentWebService</literal> that we expose through the main method. </para>

			<para>Since the usage of the webservice is independent of the underlying implementation, we give
			here only a Java example of how to access the webservice. However, you can simply use your favorite browser.</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservice_cma_client_full.snip"/></textobject></programlisting>

		   <para>In the <literal>CMAgentWebService</literal>, we need to write 3 lines of code to use the
	active object as an webservice.</para>

         <programlisting language="java"><textobject><textdata fileref="automatic_snippets/webservice_cma_skeleton.snip"/></textobject></programlisting>

      </section>
		<section xml:id="ProposedWork_2"><info><title>Proposed Work</title></info>

         <para>
         You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/webservice/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/cmagent/webservice/</literal>.
         </para>

			<orderedlist>
			<listitem><para>Get a WebServicesFactory using a static method of the AbstractWebServicesFactory class</para> </listitem>
			<listitem><para>Get a WebServices using the WebServicesFactory instance you have just got</para></listitem>
			<listitem><para>Expose your active object using this WebServices instance</para></listitem>
			</orderedlist>

         <para>
            Once filled in, go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] cmagent.webservice</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/CMAgent</literal> directory and launch the <literal>exposeCMA.[sh|bat] [url]</literal> script
            to execute your code. The url is only needed when you want to deploy the agent on an external application server.
         </para>

		</section>
		<section xml:id="SolutionAndCode_1"><info><title>Solution And Code</title></info>


			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/ws_call.snip"/></textobject></programlisting>
			<para>
				Refer to
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../AdvancedFeatures/multiple_html/WebServices.html">Exporting active objects and components as Web Services</link>
				to get more information about web services exposition.
			</para>
		</section>
	</section>

	<section xml:id="Primalitytesttutorial_18"><info><title>Primality test tutorial</title></info>

		<indexterm>
			<primary>Tutorial</primary>
			<secondary>Primality test</secondary>
		</indexterm>

	<para>
		This chapter presents a step by step tutorial whose the purpose is to develop a distributed application to test if a number is prime using a self-made master/worker.

		The program to be created is a distributed version of a sequential
		primality test. The parallelism shown here is called data-level parallelism because the same operation can be applied simultaneously to multiples piece of data.
	</para>

	<itemizedlist>
		<listitem>
			<para>
				The first step is to study the sequential version of the application and to determinate what could be parallelized.
			</para>
		</listitem>

		<listitem>
			<para>
				The second part introduces the distribution of the computation using the Computing and Monitoring agents from the previous tutorial.
				This part highlights the use of asynchronous communications and future monitoring as well as a straightforward round-robin load-balancer.
			</para>
		</listitem>

		<listitem>
			<para>
				Finally, the last part of the tutorial presents the Master-Worker API featured by ProActive.
				This API removes all the complexity introduced by the distribution simply by handling it internally.
			</para>
		</listitem>
	</itemizedlist>

	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->
	<!-- Sequential version -->
	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->


		<!-- ARCHITECTURE -->

		<section xml:id="ASequentialVersionofthePrimalityTest_18"><info><title>A Sequential Version of the Primality Test</title></info>

			<para>
				In this section, we will look at a simple sequential
				version of the application to find if a candidate number is
				prime.
			</para>
		<section xml:id="ArchitectureoftheSequentialVersion_1"><info><title>Architecture of the Sequential Version</title></info>

			<para>
				The provided application uses a straightforward algorithm: Given a
				candidate number m, the algorithm loops over all the integers from 2 to
				square root of m (rather than to m  1). At each step, it divides the candidate number
				m by the current integer (the running divisor).
				The loop ends when either:
				</para>

			<itemizedlist>
				<listitem><para>the running divisor divides the candidate number and then,
				the candidate number is not a prime number.</para>
				 </listitem>
			<listitem><para>the running divisor is greater than the square root of the
         candidate number and so, the candidate number is prime.</para>
				 </listitem>
			</itemizedlist>

         <para>
         You can find code for this version into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/primes/sequential/</literal>
         directory.
         </para>


		</section>

		<!-- IMPLEMENTATION -->

		<section xml:id="ImplementationoftheSequentialVersion_18"><info><title>Implementation of the Sequential Version</title></info>

			<para>
				The <literal>main</literal>
				method selects a range between 2 and the square root of the candidate and
				calls <literal>isPrime</literal>
				method that tries to divide the candidate by a divider in
				a given range.

				For this example a prime number is given as candidate by
				default.
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_sequential_main.snip"/></textobject></programlisting>
		</section>

		<!-- RUNNING -->

		<section xml:id="RunningtheSequentialVersion_18"><info><title>Running the Sequential Version</title></info>

         <para>
            Go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] primes.sequential</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/Primes</literal> directory and launch the <literal>sequential.[sh|bat]</literal> script
            with the integer you want to test.
         </para>
         <para>
         <screen>sequential.[sh|bat] 2147483647</screen>
         </para>
		</section>
	</section>

	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->
	<!-- Distributed version -->
	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->

	<section xml:id="ADistributedVersionofthePrimalityTest_18"><info><title>A Distributed Version of the Primality Test</title></info>

		<para>
			In this section, we will distribute the computation using
			agents from the precedent tutorial.
		</para>

		<!-- CLASSES USED -->

		<section xml:id="ClassesUsed_8"><info><title>Classes Used</title></info>

			<itemizedlist><info><title xml:id="ProActive_118">ProActive</title></info>

				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.api.PAActiveObject
						</literal>
						- used to create an instance of an active object
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment
						</literal>
						- used for the deployment
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.api.PAFuture
						</literal>
						- used to catch the exceptions that the creation
						of the active object might throw
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.core.util.wrapper.BooleanWrapper
						</literal>
						- used to wrap the primitive boolean type
					</para>
				</listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para></listitem>

			</itemizedlist>
			<itemizedlist><info><title xml:id="Other_118">Other</title></info>

				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.examples.userguide.cmagent.simple.CMAgent
						</literal>
						- parent class of the workers
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>java.util.Vector</literal>
						- used by the manager to store future results
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<!-- ARCHITECTURE -->

		<section xml:id="ArchitectureoftheDistributedVersion_1"><info><title>Architecture of the Distributed Version</title></info>

			<para>
				The test range from 2 to
            <inlinemediaobject>
               <imageobject>
                  <imagedata scalefit="1" scale="70" valign="bottom" fileref="images/png/guided_tour/square_root.png" format="PNG"/>
               </imageobject>
            </inlinemediaobject>
            is divided into a number of intervals that will be sent
				asynchronously to workers by the manager using a round-robin
				algorithm. Once all intervals have been sent, the manager
				waits for any answers and checks the result.
			</para>
			<para>
				<figure xml:id="DistributionoftheTestRangeExamplewith2_18"><info><title>Distribution of the Test Range (Example with 2 Workers)</title></info>

					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/guided_tour/primes_dg.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				Each worker serves requests in a FIFO order, meanwhile the order
				of result reception by the manager is nondeterministic, it depends on
				various factors like workers load, network latency, etc.
			</para>
			<para>
				<literal>CMAgentPrimeWorker</literal> and <literal>CMAgentPrimeManager</literal> classes have several methods
				implementing the mechanism described above. The manager
				class has a method for adding workers to its list
				(<literal>addWorker(CMAgentPrimeWorker)</literal>),
				and a method that distributes the workload by
				performing method calls on workers
				(<literal>isPrime(long number)</literal>).
				The worker class has a method that checks if a number
				is prime
				(<literal>
					isPrime(long number, long begin, long end)
				</literal>).

				A main class is used to deploy the manager and its
				workers on a specified deployment descriptor.

				For this example, the manager and worker classes without
				code look like hereafter. Try to fill in the code for the
				methods. An example implementation is also provided
				below.
			</para>

			<!-- SKELETON CODE -->

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_manager_skeleton.snip"/></textobject></programlisting>

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_worker_skeleton.snip"/></textobject></programlisting>

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_main_skeleton.snip"/></textobject></programlisting>


         <para>
         You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/primes/distributed/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/primes/distributed/</literal>.
         </para>

			<!-- FT-TEST -->

			<para>
				Once the code filled and the application run successfully,
				let's simulate a crash on a worker JVM to know if this application
				is fault-tolerant.
			</para>

			<para>
				For this purpose add a <literal>Thread.sleep()</literal> in the
				<literal>isPrime</literal> method of the <literal>CMAgentPrimeWorker</literal> class
				in order to have time to monitor this application with IC2D.
			</para>

			<para>
				From IC2D right-click on the JVM that contains a worker
				and hit the "Kill This JVM" option. Then Expect The Unexpected !
			</para>

			<para>
				<figure xml:id="KillingaJVMfromIC2D_18"><info><title>Killing a JVM from IC2D</title></info>

					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/guided_tour/primes_dg_killing_jvm_screen.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				Typically, the user will need to catch a
				<literal>org.objectweb.proactive.core.body.exceptions.FutureMonitoringPingFailureException</literal>
				exception manually to handle such failures.
			</para>

			<para>
				Moreover, the application will never end or return an incorrect result since the manager will
				wait infinitely for an answer that never comes from a crashed worker.
			</para>

		</section>

		<!-- SOLUTION -->

		<section xml:id="SolutionFullCode_10"><info><title>Solution/Full Code</title></info>


			<para>
				The <literal>Main</literal>
				class that deploys the manager and the workers.
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_main.snip"/></textobject></programlisting>

			<para>
				The <literal>CMAgentPrimeManager</literal>
				class that distributes the intervals to workers.
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_manager.snip"/></textobject></programlisting>

			<para>
				The <literal>CMAgentPrimeWorker</literal>
				class that tests whether a candidate is prime.
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributed_worker.snip"/></textobject></programlisting>
		</section>

		<!-- RUNNING -->

		<section xml:id="RunningtheDistributedVersion_18"><info><title>Running the Distributed Version</title></info>

         <para>
            Go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] primes.distributed</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/Primes</literal> directory and launch the <literal>distributed.[sh|bat]</literal> script
            with the integer you want to test.
         </para>
         <para>
         <screen>distributed.[sh|bat] 2147483647</screen>
         </para>

		</section>
	</section>

	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->
	<!-- Distributed MW version -->
	<!-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA -->

	<section xml:id="ADistributedVersionofthePrimalityTestUsingtheMasterWorkerAPI"><info><title>A Distributed Version of the Primality Test Using the Master-Worker API</title></info>

		<indexterm>
			<primary>Tutorial</primary>
			<secondary>Primality test</secondary>
			<tertiary>Using Master-Worker API</tertiary>
		</indexterm>
		<para>
			In this section, we will distribute the computation using
			the Master-Worker API.
		</para>

		<!-- CLASSES USED -->

		<section xml:id="ClassesUsed_9"><info><title>Classes Used</title></info>

			<itemizedlist><info><title xml:id="ProActive_1">ProActive</title></info>

				<listitem><para><literal>org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment</literal> - used for the deployement</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMApplication</literal> - represents the application which is being deployed</para></listitem>
            <listitem><para><literal> org.objectweb.proactive.gcmdeployment.GCMVirtualNode</literal> - used to control and instantiate virtual node objects</para></listitem>

				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.extensions.masterworker.ProActiveMaster
						</literal>
						- used to create a master
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>
							org.objectweb.proactive.extensions.masterworker.interfaces.Task
						</literal>
						- used to submit tasks to the master
					</para>
				</listitem>
			</itemizedlist>
			<itemizedlist><info><title xml:id="Other_1">Other</title></info>

				<listitem>
					<para>
						<literal>java.util.List</literal>
						- used by to store the prime computation tasks
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<!-- ARCHITECTURE -->

		<section xml:id="ArchitectureoftheMasterWorkerVersion_1"><info><title>Architecture of the Master-Worker Version</title></info>


			<para>
				For this example, the master and worker classes without
				code look like hereafter. Try to fill in the code for the
				methods. An example implementation is also provided
				below.
			</para>

			<note>
				<para>
					With the Master-Worker API, there is no need to explicitly deal 
					with primitive type wrappers, these kind of pitfalls are simply handled internally.
				</para>
			</note>
			<!-- SKELETON CODE -->

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributedmw_task_skeleton.snip"/></textobject></programlisting>

			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributedmw_skeleton.snip"/></textobject></programlisting>

         <para>
         You can find the skeleton codes for this exercise into the <literal>tutorials/src/Examples/org/objectweb/proactive/examples/userguide/primes/distributedmw/</literal>
         directory. Full code is also available into the directory
         <literal>ProActive/src/Examples/org/objectweb/proactive/examples/userguide/primes/distributedmw/</literal>.
         </para>

			<!-- FT-TEST -->

			<para>
				Once the code filled in and the application successfully run,
				let's crash a worker to see the difference with the precedent application.
			</para>

			<para>
				For this purpose add a <literal>Thread.sleep()</literal> in the
				<literal>run()</literal> method of the <literal>FindPrimeTask</literal> class.
			</para>

			<para>
				Like in the precedent application, from IC2D, kill a JVM that contains a worker.
				Then expect no exceptions or errors!
			</para>

			<para>
				The main difference with the precedent application is that the master
				does not send any tasks to the workers. In fact, it is the workers
				that ask the master for tasks.
				Such "work-stealing" pattern proves to be fault-tolerant and it is one the
				benefits from using a High-Level ProActive API.
			</para>

		</section>

		<!-- SOLUTION -->

		<section xml:id="SolutionFullCode_2"><info><title>Solution/Full Code</title></info>


			<para>
				The <literal>FindPrimeTask</literal>
				class that performs the computation is as follows:
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributedmw_task.snip"/></textobject></programlisting>

			<para>
				The <literal>PrimeExampleMW</literal>
				class that deploys the master and the workers looks loke that:
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/primes_distributedmw_example.snip"/></textobject></programlisting>
		</section>

		<!-- RUNNING -->

		<section xml:id="RunningtheMasterWorkerVersion_18"><info><title>Running the Master-Worker Version</title></info>

         <para>
            Go to the <literal>tutorials/compile</literal> directory and type <literal>build[.bat] primes.distributedmw</literal> to compile your code.
            Then, after a successful compilation, go to the <literal>scripts/Primes</literal> directory and launch the <literal>distributedMW.[sh|bat]</literal> script
            with the integer you want to test.
         </para>
         <para>
         <screen>distributedMW.[sh|bat] 2147483647</screen>
         </para>
		</section>

	</section>
	</section>

</chapter>
