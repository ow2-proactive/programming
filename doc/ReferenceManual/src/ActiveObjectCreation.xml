<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ActiveObjectCreation"><info><title xml:id="ActiveObjectsCreationAndAdvancedConcepts_71">Active Objects: Creation And Advanced Concepts</title></info>


	<section xml:id="Overview_71"><info><title>Overview</title></info>

		<para>
			Active objects are created on a per-object basis: an
			application can contain active as well as passive instances
			of a given class. In this section, we will present the three
			methods for creating active instances of classes and how to
			use arguments passed to the methods to control creation.
			Although almost any object can be turned into an Active
			Object, there are some restrictions that will be detailed
			below. We will also present a deep explanation of the
			active object structure and behavior. Examples in
			this chapter contain only the code necessary for the creation of
			active objects. To see how to start nodes, JVMs, and
			virtual nodes on which objects can be instantiated, please refer to
			<xref linkend="Configuration"/>
		</para>

		<para>
			In <emphasis role="bold">ProActive</emphasis>,
			there are two ways to create active objects: instantiation
			based creation and by using an existing object. Instantiation
			based creation is done through the
			<literal>PAActiveObject.newActive(...)</literal>
			and the
			<literal>PAActiveObject.newActiveInParallel(...)</literal> method
			whereas object based creation is done through the
			<literal>PAActiveObject.turnActive(...)</literal> method.
			These methods are part of the
			<literal>org.objectweb.proactive.api</literal>
			package. Each method takes several parameters that indicate
			how the active object is created and most of the parameters
			are common among creation methods. All the available
			creation methods with parameters are presented in the
			<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../api_published/org/objectweb/proactive/api/PAActiveObject.html">
				paactiveobject javadoc
			</link>.
		</para>
		<para>
			For the examples described in this chapter, we will use the following
			class that can be instantiated as an active	object:
		</para>
		<programlisting language="java"><textobject><textdata fileref="code_snippets/class_Worker.snip"/></textobject></programlisting>

	</section>

	<section xml:id="ActiveObjectCreation_html_restrictions"><info><title xml:id="Restrictionsoncreatingactiveobjects_71">Restrictions on creating active objects</title></info>

		<para>
			Not all classes can be used to instantiate active objects.
			There are some restrictions, most of them being caused by the 100%
			Java compliance, which forbids the modification of the Java Virtual
			Machine and of the compiler.
		</para>

		<para>Some of these restrictions are at class-level such as:</para>

		<itemizedlist>
			<listitem>
				<para>
					final classes cannot be used to instantiate active
					object
				</para>
			</listitem>

			<listitem>
				<para>
					non public classes cannot be used to instantiate
					active object
				</para>
			</listitem>

			<listitem>
				<para>
					classes without a no-argument constructor cannot be
					reified
				</para>
			</listitem>

		</itemizedlist>

		<para>
			Member classes (i.e. non-static named internal classes) can be
			used to instantiate active objects only through the
			<literal>PAActiveObject.turnActive(...)</literal> method
			(see <xref linkend="ObjectBasedCreationusingliteralPAActiveObjectturnActiveliteral_71"/>).
			In other words, an instance of a member class can only be
			activated after creation, and not directly
			created as an active object. Attempting to directly create an
			active object from a member class with
			<literal>PAActiveObject.newActive(...)</literal> method will
			throw a NotActivatableException.

			This is mainly due to the fact that active objects created
			from the same member class must share a
			reference to the enclosing instance: as
			<literal>PAActiveObject.newActive(...)</literal>
			performs a deep copy of the activated instance, the
			enclosing instance would be a different copy for each active objects.		
		</para>

		<para>
			There are also restrictions at method level within a class.
			Final methods cannot be used because the stub is created
			from the object and having methods final prevents the stub
			from overriding the methods.
		</para>

	</section>

	<section xml:id="InstantiationBasedCreation_71"><info><title>Instantiation Based Creation</title></info>


		<para>
			For creating new instances of active objects, we can either use the
			<literal>PAActiveObject.newActive(...)</literal> method
			or
			<literal>PAActiveObject.newActiveInParallel(...)</literal> one.
			ProActive also provides a way to create multiple active
			objects in parallel on several nodes.
			<literal>PAActiveObject.newActiveInParallel(...)</literal>
			creates a number of active objects deployed on one or more
			nodes. The object creation is optimized by a thread pool.
		</para>

		<para>
			When using instantiation based creation, any argument passed
			to the constructor of the reified object through
			<literal>PAActiveObject.newActive(...)</literal>
			or
			<literal>PAActiveObject.newActiveInParallel(...)</literal>
			is serialized and passed by copy to the object. That is
			because the model behind
			<emphasis role="bold">ProActive</emphasis>
			is uniform whether the active object is instantiated locally
			or remotely. Parameters are therefore guaranteed to be
			passed by copy to the constructor. When using
			<literal>PAActiveObject.newActive(...)</literal>,
		   one needs to make sure that the constructor arguments are
			<literal>Serializable</literal>.
			On the other hand, the class used to create the active
			object does not need to be
			<literal>Serializable</literal>
			even in the case of remotely-created Active Objects. Bear in
			mind also that a reified object must have a declared empty
			no-args constructor in order to be properly created.
		</para>

		<section xml:id="using_PAActiveObjectnewActive"><info><title>Using <code>PAActiveObject.newActive(...)</code></title></info>


			<para>
				To create a single active object from the class
				<literal>Worker</literal>
				in the local JVM, we use the code hereafter. If the
				invocation of the constructor of class
				<literal>Worker</literal>
				throws an exception, it is placed inside an exception of
				type
				<literal>ActiveObjectCreationException</literal>.
				When the call to
				<literal>newActive</literal>
				returns, the active object has been created and its
				active thread is started.
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_1.snip"/></textobject></programlisting>
		</section>


		<section xml:id="newActiveInParallel_nodes"><info><title>
				Using
				<literal>
					PAActiveObject.newActiveInParallel(...)
				</literal>
			</title></info>


			<para>
				The following code deploys an active object on nodes
				contained in the virtual node
				<literal>VN</literal> (current nodes).
				In this case, the
				<literal>Worker</literal>
				constructor does not take any arguments. However, we have
				to create an
				<literal>Object</literal>
				array whose length is equal to the number of nodes. The
				creation of active objects is optimized by a thread
				pool. When the call to
				<literal>newActiveInParallel</literal>
				returns, the active objects have been created and their
				threads have been started.
			</para>
			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_2.snip"/></textobject></programlisting>


		</section>


	</section>

	<section xml:id="ObjectBasedCreationusingliteralPAActiveObjectturnActiveliteral_71"><info><title>Object Based Creation using <literal>PAActiveObject.turnActive(...)</literal></title></info>


		<para>
			Object based creation is used for turning an existing
			passive object instance into an active one. It has been
			introduced in ProActive as an answer to the problem of
			creating active objects from already existing objects for
			which we do not have access to the source code.
		</para>

		<para>
			Since the object already exists before turning it active,
			there is no serialization involved when we create the
			object. When we invoke
			<literal>PAActiveObject.turnActive</literal>
			on the object, two cases are possible. If we create the
			active object locally (on a local node), it will not be
			serialized. If we create the active object remotely (on a
			remote node), the reified object will be serialized.
			Thus, if the
			<literal>turnActive</literal>
			is done on a remote node, the class used to create the
			active object this way has to be
			<literal>Serializable</literal>.
			In addition, when using
			<literal>turnActive</literal>
			, care must be taken that no other references to the
			originating object are kept by other objects after the call
			to turnActive. A direct call to a method of the originating
			object without passing by a ProActive stub on this object
			will break the ProActive model.
		</para>

		<para>
			The simplest code for object based creation looks like this:
		</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_3.snip"/></textobject></programlisting>

		<para>
         In this case, the active object is created locally in the current node.
			However, you can specify a second parameter which
			is the location where the active object will be created.
      </para>

		<para>
			When using this method, the programmer has to make sure that
			no other reference on the passive object exist after the
			call to
			<literal>PAActiveObject.turnActive(...)</literal>.
			If such references are used for calling methods directly
			on the passive object (without going through its stub,
			proxy, and body), the model will not be consistent and
			specialization of synchronization will no be guaranteed.
		</para>

	</section>


	<section xml:id="ActiveObjectCreationArguments_71"><info><title>Active Object Creation Arguments</title></info>


		<section xml:id="using_classname_and_target"><info><title>Using <code>classname</code> and <code>target</code></title></info>

			<para>
				<literal>PAActiveObject.newActive(...)</literal>
				and
				<literal>
					PAActiveObject.newActiveInParallel(...)
				</literal>
				always take as a first argument the class name from
				which the active object will be instantiated. The
				<literal>classname</literal>
				argument must be of type
				<literal>java.lang.String</literal>
				and its value is usually obtained by calling
				<literal>ClassToInstantiateFrom.class.getName()</literal>.

				<literal>PAActiveObject.turnActive(...)</literal>
				does not create an active object from a class but from
				an existing object, therefore it takes as a first
				argument the object to be turned active.
			</para>
		</section>

		<section xml:id="UsingConstructorArguments_71"><info><title>Using Constructor Arguments</title></info>

			<para>

				In order to create the active object,
				<literal>PAActiveObject.newActive(...)</literal>
				and
				<literal>
					PAActiveObject.newActiveInParallel(...)
				</literal>
				have to take a list of constructor arguments to be passed
				to the constructor of the class to be instantiated as an
				active object. Arguments to the constructor of the class
				have to be passed as an array of
				<literal>Object</literal>.
				Also, we have to make sure that the constructor
				arguments are
				<literal>Serializable</literal>
				since they are passed by a serialized copy to the
				object. The ProActive runtime determines which
				constructor of the class to call according to the type
				of the elements of this array. Nevertheless, there is
				still room for some ambiguity in resolving the
				constructor because as the arguments of the constructor
				are stored in an array of type
				<literal>Object[]</literal>
				or
				<literal>Object[][]</literal>.
				If one argument is null the runtime can obviously not
				determine its type. In this case a exception is thrown
				specifying that ProActive cannot determine the
				constructor. In the example below, an ambiguity exists
				between the two constructors if the corresponding
				element of the
				<literal>Object</literal>
				array is
				<literal>null</literal>
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_4.snip"/></textobject></programlisting>
			<para>
				If we use
				<literal>
					PAActiveObject.newActiveInParallel(..., Nodes[]
					nodes)
				</literal>
				we have the make sure that the length of the first dimension
				of
				<literal>java.lang.Object[][]</literal>
				is equal to the number of nodes since an active object
				will be deployed on each node. The second dimension contains
            the number of the constructor arguments for each
				deployed active object. Different active objects can
				have different constructor arguments.

<!--				If we use-->
<!--				<literal>-->
<!--					PAActiveObject.newActiveInParallel(..., VirtualNode-->
<!--					virtualNode)-->
<!--				</literal>-->
<!--				the virtual node will be activated if it is not active-->
<!--				and one active object will be started on each node-->
<!--				contained in the virtual node. In this case all the-->
<!--				active objects take the same constructor arguments as we-->
<!--				use a one dimensional array-->
<!--				<literal>java.lang.Object[]</literal>-->
<!--				.-->
			</para>
		</section>

		<section xml:id="UsingParameterizedClasses_71"><info><title>Using Parameterized Classes</title></info>
		   <para>
            If you want to instantiate a generic object as an active object, you have to specify its type parameters
            into the constructor methods. For instance, let's consider the generic class <literal>Pair</literal> hereafter:
         </para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/class_Pair.snip"/></textobject></programlisting>

         <para>
            <literal>Pair</literal> is a generic class which requires two type parameters. When we create an active object
            using this class, we have to specify these two types. This is done through the
            second argument of the <literal>PAActiveObject.newActive()</literal> method
            which has to be an array of classes.
            In that case, the array of constructor arguments is therefore moved to
            the third position of the arguments of <literal>PAActiveObject.newActive()</literal>.
         </para>

         <para>
            Thus, instantiation of a <literal>Pair</literal> active object will look like this:
         </para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_5.snip"/></textobject></programlisting>

         <para>
            As you can see, we have created an active object of <literal>Pair</literal> whose type parameters are
            <literal>Worker</literal> and <literal>String</literal>. As the constructor used for this creation takes
            the two type parameters as parameters, we gave a <literal>Worker</literal> (first type parameter) and
            a <literal>String</literal> to the <literal>PAActiveObject.newActive()</literal> method.
         </para>
         <para>
            We have presented this particularity using the <literal>PAActiveObject.newActive()</literal> method but obviously,
            it can also be applied to the <literal>PAActiveObject.newActiveInParallel()</literal> method as well as to
            the <literal>PAActiveObject.turnActive()</literal> method.
         </para>
		</section>

		<section xml:id="UsingANode_71"><info><title>Using A Node</title></info>

			<para>
				In order to create the new active object on a specific
				(remote) JVM, we can also give a node as parameter to
            <literal>newActive</literal> method. The JVM is identified using a
				<literal>Node</literal>
				object or a
				<literal>String</literal>
				that contains an URL pointing to the node. If this
				parameter is not given, the active object is created in
				the current JVM and is attached to a default
				<literal>Node</literal>.
				The node argument or the URL string can be used with
				<literal>PAActiveObject.newActive(...)</literal>
				and
				<literal>PAActiveObject.turnActive(...)</literal>.
				As for the <literal>PAActiveObject.newActiveInParallel(..)</literal>
            method, we can specify nodes using an array of
				<literal>Node</literal> since we create several active objects.
            In that case, an active object will be created on each node contained in
            this array.
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_6.snip"/></textobject></programlisting>

			<para>
				To deploy using the URL of a node, we just have to replace the node previously used
				by its URL:
			</para>
			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_7.snip"/></textobject></programlisting>
			<para>
				If you want to use the
				<literal>PAActiveObject.turnActive(...)</literal> method instead of the
            <literal>PAActiveObject.newActive(...)</literal> one, you can proceed
            exactly in the same way as previously.
			</para>
			<para>
				In order to deploy several active objects with
				<literal>
					PAActiveObject.newActiveInParallel(...)
				</literal>,
				we can only pass an array of
				<literal>Node</literal>
				(see the example in
				<xref linkend="newActiveInParallel_nodes"/>).
            </para>

		</section>

		<section xml:id="ActiveObjectCreationWithCustomActivity"><info><title xml:id="UsingACustomActivity_71">Using A Custom Activity</title></info>



			<para>
				Customizing the activity of the active object is at the
				core of ProActive because it allows to specify fully the
				behavior of an active object. By default, an object
				turned into an active object serves its incoming
				requests in a FIFO manner. In order to specify another
				policy for serving the requests or to specify any other
				behaviors, we can implement interfaces defining methods
				that will be automatically called by ProActive.
			</para>

			<para>
				It is possible to specify what to do before the activity
				starts, what the activity is and what to do after it
				ends. The three steps are:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						the initialization of the activity (done only
						once)
					</para>
				</listitem>

				<listitem>
					<para>the activity itself</para>
				</listitem>

				<listitem>
					<para>
						the end of the activity (done only once)
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Three interfaces are used to define and implement each
				step:
			</para>

			<itemizedlist>
				<listitem>
					<para><literal>InitActive</literal> - contains the <literal>initActivity(Body body)</literal> method to be implemented</para>
				</listitem>

				<listitem>
					<para><literal>RunActive</literal> - contains the <literal>runActivity(Body body)</literal> method to be implemented</para>
				</listitem>

				<listitem>
					<para><literal>EndActive</literal> - contains the <literal>endActivity(Body body)</literal> method to be implemented</para>
				</listitem>
			</itemizedlist>

<!--         <para>-->
<!--            These three methods can either be implemented into the class we want to turn into active or into a external class.-->
<!--            Using an external class, we have to instantiate an object of this class and then give it to the <literal>newActive()</literal>-->
<!--            method as parameter. Obviously, that also works with the <literal>newActiveInParallel()</literal> and <literal>turnActive()</literal>-->
<!--            methods.-->
<!--         </para>-->

			<para>
				In case of a migration, an active object stops and
				restarts its activity automatically without invoking the
				initialization or ending phases. Only the activity
				itself is restarted.
			</para>

			<para>
			   They are two ways to define each of the three phases
				of an active object:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						implementing one or more of the three interfaces
						directly in the class used to create the active
						object
					</para>
				</listitem>

				<listitem>
					<para>
						passing an object implementing one or more of
						the three interfaces in parameter to the method
						<literal>newActive</literal>,
						<literal>newActiveInParallel</literal> or
						<literal>turnActive</literal>
						(parameter <literal>activity</literal> of the
						type <literal>Active</literal>
						in those methods).
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Note that methods defined by those 3 interfaces are
				guaranteed to be called by the active thread of the
				active object.
			</para>

			<section xml:id="Algorithmsdecidingwhichactivitytoinvoke"><info><title>Algorithms deciding which activity to invoke</title></info>


				<para>
               Activity invocations follow the
               algorithm hereafter (<literal>activity</literal>
					is the object passed as a parameter to
					<literal>newActive</literal>
					or
					<literal>turnActive</literal>):
				</para>


         <figure xml:id="Activityalgorithm_71"><info><title>Activity algorithm</title></info>
            <mediaobject>
               <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/init_run_end_Activity.png"/>
               </imageobject>
            </mediaobject>
         </figure>

         <para>
            When the active object is about to be instantiated, if an <literal>activity</literal> object has been given to the creation method and if
            it implements the <literal>initActivity</literal> method, then this method is executed. Else, if the object
            we want to activate implements this method, then this one is executed. Otherwise, no method is executed before the active object creation.
         </para>
         <para>
            In the same way, the activity itself used for the object is first the one defined in the <literal>activity</literal> object (implementing
            the <literal>runActivity</literal> method). Then, if no <literal>runActivity</literal> method has been defined in an <literal>activity</literal>
            object, the one defined in the object itself is executed. Otherwise, the standard activity phase will be used (which serves requests in a
            FIFO order).
         </para>
         <para>
            Finally, when terminating the active object, the same scenario occurs. In that case, as it was for the initialising phase, if no
            <literal>endActivity</literal> method has been defined anywhere, no method will be executed. In other word, there is no default behaviour
            for ending.
         </para>
         <note>
            <para>
            If an activity method (<literal>initActivity</literal>, <literal>runActivity</literal> or <literal>endActivity</literal>) is implemented
            both in an <literal>activity</literal> object passed as parameter to the creation method
            and also in the object we want to activate, then it is the method defined in the <literal>activity</literal> object that will be executed.
            This behaviour enables in particular to override activity phases of an object that we do not have access to its code
            (or that we do not want to modify).
            </para>
         </note>

			</section>

			<section xml:id="Implementingtheinterfacesdirectlyintheclass"><info><title>Implementing the interfaces directly in the class</title></info>


				<para>
					Implementing the interfaces directly in the class
					used to create the active object is the easiest
					solution when you control the class that you make
					active. Depending on which phase in the life of the
					active object you want to customize, you have to implement
					the corresponding interface (one or more):
					<literal>InitActive</literal>,
					<literal>RunActive</literal>
					and
					<literal>EndActive</literal>.
					Here is the <literal>Worker</literal> into which we have customized its
					initialization and its ending.
				</para>

				<programlisting language="java"><textobject><textdata fileref="code_snippets/class_Worker_With_Activity.snip"/></textobject></programlisting>

						<para>
							Here is the skeleton code for a class that
							can run, suspend, restart and stop a
							simulation. It uses a implementation of
							<literal>RunActive</literal>
							to provide the necessary control.
						</para>


                  <programlisting language="java"><textobject><textdata fileref="code_snippets/class_Simulation.snip"/></textobject></programlisting>

			</section>

			<section xml:id="Passinganobjectimplementingtheinterfacesatcreationtime"><info><title>Passing an object implementing the interfaces at creation time</title></info>


				<para>
					Passing an object implementing the interfaces is the
					solution to use when we do not control the class
					that we make active or when you want to write a
					generic activity policy and reuse it with several
					active objects. Depending on which phase in the life
					of the active object we want to customize, we will
					implement the corresponding interface (one or more)
					from
					<literal>InitActive</literal>
					,
					<literal>RunActive</literal>
					and
					<literal>EndActive</literal>
					. Following is an example that has a custom
					activity.
				</para>

				<para>
					First we need to implement the activity that it will
					be passed to the active object. We do so by
					implementing one or more interfaces.
				</para>
				<programlisting language="java"><textobject><textdata fileref="code_snippets/class_LIFOActivity.snip"/></textobject></programlisting>
				<para>
					The implemented interface can be used with any of the creation methods
					(<literal>PAActiveObject.newActive(...)</literal>, <literal>PAActiveObject.newActiveInParallel(...)</literal>
					or
					<literal>PAActiveObject.turnActive(...)</literal>).
					.
				</para>
				<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_8.snip"/></textobject></programlisting>

			</section>

		</section>

		<section xml:id="ActiveObjectCreation_html_factory"><info><title xml:id="UsingthefactorypatternwithActiveObjects_71">Using the factory pattern with Active Objects</title></info>

			<para>
				Creating an active object using ProActive might be a
				little bit cumbersome and requires more lines of code
				that for creating a regular object. A nice solution to
				this problem is through the use of the
				<emphasis role="bold">factory</emphasis>
				pattern. This mainly applies to class based creation. It
				consists in creating a
				<literal>WorkerFactory</literal> class with
            a static method to class
				that takes care of instantiating the active object and
				returns it.
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/class_WorkerFactory.snip"/></textobject></programlisting>
			<para>
				The static method in the factory class is then used to
				create active objects:
			</para>
			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_9.snip"/></textobject></programlisting>

			<para>
				It is up to the programmer to decide whether this method
				has to throw exceptions or not. We recommend that this
				method only throw exceptions that appear in the
				signature of the reified constructor (none here as the
				constructor of Worker that we call doesn't throw any
				exception). However, the non functional exceptions
				induced by the creation of the active object have to be
				dealt with somewhere in the code.
			</para>
		</section>



		<section xml:id="using_metaobjects_to_customize"><info><title>Using <literal>MetaObjectFactory</literal> to customize the meta objects</title></info>


			<para>
				There are many cases where you may want to customize the
				body used when creating an active object. For instance,
				one may want to add some debug messages or some timing
				behavior when sending or receiving requests. The body is
				a non changeable object that delegates most of its tasks
				to helper objects called MetaObjects. Standard
				MetaObjects are already used by default in ProActive but
				one can easily replace any of those MetaObjects by a
				custom one.
			</para>

			<para>
				We have defined a
				<literal>MetaObjectFactory</literal>
				interface that is able to create factories for each of
				those MetaObjects. This interface is implemented by
				<literal>ProActiveMetaObjectFactory</literal>
				which provides all the default factories used in
				ProActive.
			</para>

			<para>
				When creating an active object, it is possible to
				specify which
				<literal>MetaObjectFactory</literal>
				to use for that particular instance of active object
				being created.
			</para>

			<para>
				First you have to write a new MetaObject factory that
				inherits from
				<literal>ProActiveMetaObjectFactory</literal>
				or directly implements the
				<literal>MetaObjectFactory</literal>
				interface. Inheriting from
				<literal>ProActiveMetaObjectFactory</literal>
				is a great time saver as you only redefine what you
				really need to as opposed to redefining everything when
				inheriting from
				<literal>MetaObjectFactory</literal>
				. Here is an example:
			</para>

         <programlisting language="java"><textobject><textdata fileref="code_snippets/class_CustomMetaObjectFactory.snip"/></textobject></programlisting>

			<para>
				The factory above simply redefines the
				<literal>RequestFactory</literal>
				in order to make the body use a new type of request. The
				method
				<literal>
					protected RequestFactory
					newRequestFactorySingleton()
				</literal>
				is one convenience method that
				<literal>ProActiveMetaObjectFactory</literal>
				 provides to simplify the creation of factories as
				singleton.
				<programlisting language="java"><textobject><textdata fileref="code_snippets/proactivemetaobjectfactory.snip"/></textobject></programlisting>

				More explanations can be found in the
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../../api_published/index.html">
				javadoc
				</link>
            of the <literal>org.objectweb.proactive.core.body.ProActiveMetaObjectFactory</literal> class.
				The use of that factory is fairly simple. All you have
				to do is to pass an instance of the factory when
				creating a new active object. If we take the same
				example as before we have:
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_10.snip"/></textobject></programlisting>

		</section>
	</section>



	<section xml:id="ActiveObjectCreation_html_elementRole"><info><title>
			Elements of an active object and futures
		</title></info>


		<para>
			In this section, we'll have a very close look at what
			happens when an active object is created. This section aims
			at providing a better understanding of how the library works
			and where the restrictions of Proactive come from.
		</para>

		<para>
			Consider that some code of a class
			<literal>A</literal>
			creates an active object of class
			<literal>Worker</literal>
			using a piece of code like this:
		</para>

	<programlisting language="java"><textobject><textdata fileref="code_snippets/AO_Creation_1.snip"/></textobject></programlisting>

		<para>
			If the creation of the active instance of A is successful,
			the graph of objects is as described in the following figure (with
			arrows denoting references):
		</para>

		<para>
			<figure xml:id="Thecomponentsofanactiveobjectandof_710"><info><title>The components of an active object and of a referencing object</title></info>


				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/workerActiveObject.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
		</para>

		<para>
			The active instance of Worker is composed of 2 objects:
		</para>
	<itemizedlist>
			<listitem>
				<para>
					a body (
					<literal>Body</literal>
					)
				</para>
			</listitem>

			<listitem>
				<para>
					an instance of
					<literal>Worker</literal>
				</para>
			</listitem>
		</itemizedlist>
		<para> Besides the active object composed of a body and an object, there is
		also a proxy and a stub for each active or passive object referencing the active object.

		</para>

		<section xml:id="Roleofthestub_71"><info><title>Role of the stub</title></info>


			<indexterm>
				<primary>Stub</primary>
			</indexterm>

			<para>
				The role of the class
				<literal>Stub_Worker</literal>
				is to reify all method calls that can be performed
				through a reference of type
				<literal>Worker</literal>.
				Reifying a call simply means constructing an object
				that represents the call (in
				our case, all reified calls are instance of class
				<literal>org.objectweb.proactive.core.mop.MethodCall</literal>),
				so it can be
				manipulated as any other object. The reified call is
				then processed by the other components of the active
				object in order to achieve the behavior we expect from
				an active object.
			</para>

			<para>
				Using a standard object for representing
				elements of the language that are not normally objects
				(such as method calls, constructor calls, references,
				types,...) is at the core of
				<emphasis>metaobject programming</emphasis>.
				The ProActive metaobject protocol (MOP) is
				is described in
				<link xlink:href="../../AdvancedFeatures/multiple_html/MOP.html">Chapter 43. MOP: Metaobject Protocol</link>.
				but it is not a prerequisite for understanding and using
				ProActive.
			</para>

			<para>
				As one of our objectives is to provide transparent
				active objects, references to active objects of class
				<literal>Worker</literal>
				need to be of the same type as references to passive
				instances of
				<literal>Worker</literal>
				(this feature is called
				<emphasis>polymorphism</emphasis>
				between passive and active instances of the same class).
				This is why
				<literal>Stub_Worker</literal>
				is a subclass of class
				<literal>Worker</literal> by construction,
				 therefore allowing instances of class
				<literal>Stub_Worker</literal>
				to be assigned to variables of type
				<literal>Worker</literal>.
			</para>

			<para>
				Class
				<literal>Stub_Worker</literal>
				redefines each of the methods inherited from its
				superclasses. The code of each method of class
				<literal>Stub_Worker</literal>
				builds an instance of class
				<literal>org.objectweb.proactive.core.mop.MethodCall</literal>
				in order to represent the call to this method. This
				object is then passed to the
				<literal>BodyProxy</literal>,
				which returns an object that is returned as the result
				of the method call. From the caller's point of view,
				everything looks like if the call had been performed on
				an instance of
				<literal>Worker</literal>.
			</para>

			<para>
				Now that we know how stubs work, we can understand some
				of the limitations of ProActive:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						Obviously,
						<literal>Stub_Worker</literal>
						cannot redefine
						<literal>final</literal>
						methods inherited from class
						<literal>Worker</literal>.
						If methods are final, calls to these methods are not
						reified but are executed on the stub, which may
						lead to unpredictable behavior.
					</para>

					<para>
						As there are 6 final methods in the base class
						<literal>Object</literal>,
						there is the question of how ProActive deals with these
						methods. In
						fact, 5 out of this 6 methods deal with thread
						synchronization (<literal>notify()</literal>,
						<literal>notifyAll()</literal>
						and the 3 versions of
						<literal>wait()</literal>).
						Those methods should not be used since an
						active object provides thread synchronization.
						Using the standard thread
						synchronization mechanism and ProActive thread
						synchronization mechanism at the same time might
						conflict and result in an very hard to debug behaviour.
					</para>

					<para>
						The last final method in the class
						<literal>Object</literal>
						is
						<literal>getClass()</literal>.
						When invoked on an active object,
						<literal>getClass()</literal>
						is not reified and therefore performed on the
						stub object, which returns an object of class
						<literal>Class</literal>
						that represents the class of the stub (<literal>Stub_Worker</literal>
						in our example) and not the class of the active
						object itself (<literal>Worker</literal>
						in our example). However, this method is seldom
						used in standard applications and it doesn't
						prevent the operator
						<literal>instanceof</literal>
						from working thanks to its polymorphic behavior.
						Therefore the expression
						<literal>(foo instanceof Worker)</literal>
						has the same value whether Worker is active or not.
					</para>
				</listitem>

				<listitem>
					<para>
						Getting or setting instance variables directly
						(not through a get or a set method) must be
						avoided for active objects because it
						results in getting or setting the value on the
						stub object and not on the instance of the class
						<literal>Worker</literal>.
						This problem is usually worked around by using
						get/set methods for setting or reading
						attributes. This rule of strict encapsulation
						can also be found in JavaBeans or in most
						distributed object systems like RMI or CORBA.
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<section xml:id="Roleoftheproxy_71"><info><title>Role of the proxy</title></info>


			<para>
				The role of the proxy is to handle asynchronism in calls
				to active object. More specifically, it creates future
				objects if possible and needed, forwards calls to bodies,
				and returns future objects to the stubs. As this class
				operates on
				<literal>MethodCall</literal>
				objects, it is absolutely generic and does not depend at
				all on the type of the stub that feeds calls in through
				its
				<literal>reify</literal>
				method.
			</para>
		</section>

		<section xml:id="Roleofthebody_71"><info><title>Role of the body</title></info>


			<para>
				The
				<literal>body</literal>
				is responsible for storing calls (actually,
				<literal>Request</literal>
				objects) in a queue of pending requests and processing
				these requests according to a given synchronization
				policy. The default behaviour for the synchronization policy is FIFO.
				The Body has its
				own thread which chooses requests from the
				queue of requests and executes the associated call.
			</para>
		</section>

		<section xml:id="RoleoftheinstanceofclassWorker_71"><info><title>Role of the instance of class Worker</title></info>


			<para>
				There is also a standard instance of class
				<literal>Worker</literal>.
			   It may contain some synchronized information in its
				<literal>live</literal>
				method, if any. As the body executes calls one by one,
				there cannot be any concurrent execution of two portions
				of code for this object by two different threads. This
				enables the use of pre and post-conditions and class
				invariants. As a consequence, the use of the keyword
				<literal>synchronized</literal>
				in class
				<literal>Worker</literal>
				should not be necessary. Any synchronization scheme that
				can be expressed through monitors and
				<literal>synchronized</literal>
				statements can be expressed using ProActive's high-level
				synchronization mechanism in a much more natural and
				user-friendly way.
			</para>
		</section>
	</section>


	<section xml:id="FutureObjectCreation"><info><title xml:id="Asynchronouscallsandfutures_71">Asynchronous calls and futures</title></info>


		<section xml:id="CreationofaFutureObject_71"><info><title>Creation of a Future Object</title></info>


			<para>
				<!--  //TODO Explain asynchronous request -->
				Whenever it is possible, a method call on an active object is
				reified as an asynchronous request. In that case, it
				immediately returns a future object.
            If it is not possible, the
				call is synchronous and blocks until the reply is
				received.
			</para>

			<para>
				This future object acts as a placeholder for the result of the
				not-yet-performed method invocation. As a consequence,
				the calling thread can go on with executing its code, as
				long as it does not need to invoke methods on the
				returned object. At the time when the real result is needed, the calling thread is
				automatically blocked if the result of the method
				invocation is not yet available. Below are shown the
				different cases that can lead to an asynchronous call.
				Note that this table does not apply when using the
				tryWithCatch annotators to deal with asynchronous
				exceptions. See
				<xref linkend="Exceptions"/>.
			</para>


         <table>
            <title>Future creation, and asynchronous calls depending on
					return type</title>

				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="1*"/>
					<colspec colnum="2" colname="col2" colwidth="2*"/>
					<colspec colnum="3" colname="col3" colwidth="1.5*"/>
					<colspec colnum="4" colname="col4" colwidth="1*"/>
					<spanspec spanname="onetwo" namest="col1" nameend="col2"/>
					<tbody>
						<row>
							<entry spanname="onetwo">
								<para>
									<emphasis role="bold">
										Method Signature
									</emphasis>
								</para>
							</entry>
							<entry morerows="1" valign="middle">
								<para>
									<emphasis role="bold">
										Creation of a future
									</emphasis>
								</para>
							</entry>

							<entry morerows="1" valign="middle">
								<para>
									<emphasis role="bold">
										Asynchronous
									</emphasis>
								</para>
							</entry>
						</row>

						<row>
							<entry>
								<para>
									<emphasis role="bold">
										Return type
									</emphasis>
								</para>
							</entry>

							<entry>
								<para>
									<emphasis role="bold">
										Can throw checked exception
									</emphasis>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>Void</para>
							</entry>
							<entry align="center">
								<para>No</para>
							</entry>
							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>Yes</para>
							</entry>


						</row>
						<row>
							<entry>
								<para>Void</para>
							</entry>
							<entry align="center">
								<para>Yes</para>
							</entry>
							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>


						</row>


						<row>
							<entry>
								<para>Non Reifiable Object</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>
						</row>

						<row>
							<entry>
								<para>Non Reifiable Object</para>
							</entry>

							<entry align="center">
								<para>Yes</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>Reifiable Object</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>Yes</para>
							</entry>

							<entry align="center">
								<para>Yes</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>Reifiable Object</para>
							</entry>

							<entry align="center">
								<para>Yes</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>Array</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>Array</para>
							</entry>

							<entry align="center">
								<para>yes</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>

							<entry align="center">
								<para>No</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				As we can see, the creation of a future depends not only
				on the caller type, but also on the return object type.
				Creating a future is only possible if the object is
				reifiable. Although a future has a similar structure
				to an active object, a future object is not
				active. It only has a Stub and a Proxy as shown in
				the figure below:
			</para>

			<para>
				<figure xml:id="Afutureobject_71"><info><title>A future object</title></info>

					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/stubProxyFuture.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				During its lifetime, an active object can create many
				future objects. There are all automatically kept in a
				FuturePool.

			</para>

			<para>
				Each time a future is created, it is inserted in the
				future pool of the corresponding active object. When the
				result becomes available, the future object is removed
				from the pool. There are several methods in
				<literal>org.objectweb.proactive.api.ProFuture</literal>
				which provide control over the way futures are returned.
			</para>
			</section>
			<section xml:id="Methodsaffectedbyfutures_71"><info><title>Methods affected by futures </title></info>

				<para>
					Any call to a future object is reified in order to
					be blocked if the future is not yet available and
					later executed on the result object. However, two
					methods don't follow this scheme: equals and
					hashCode. They are often called by other methods
					from the Java library, like
					<literal>HashTable.add()</literal>
					and so are most of the time out of control from the
					user. This can lead very easily to deadlocks if they
					are called on a not yet available object.
				</para>
				<para>
					There are some drawbacks with this technique, the
					main one being the impossibility to have a user
					override of the default
					<literal>HashTable</literal>
					and
					<literal>equals()</literal>
					methods.
				</para>

			<itemizedlist>
				<listitem>

				<para>
					<emphasis role="bold">hashCode()</emphasis> -
					Instead of returning the hashcode of the object, it
					returns the hashcode of its proxy. Since there is
					only one proxy per future object, there is a unique
					equivalence between them.
				</para>
				</listitem>

				<listitem>

				<para>
				<emphasis role="bold">equals()</emphasis> -
					The default implementation of
					<literal>equals()</literal>
					in the Object class is to compare the references of
					two objects. In ProActive, it is redefined to compare
					the hashcode of two proxies. As a consequence, it is
					only possible to compare two future object, and not
					a future object with a normal object.
				</para>
				</listitem>

				<listitem>
				<para>
					<emphasis role="bold">toString()</emphasis> -
					The
					<literal>toString()</literal>
					method is most of the time called with
					<literal>System.out.println()</literal>
					to turn an object into a printable string. In the
					current implementation, a call to this method will
					block on a future object like any other call, thus,
					one has to be careful when using it. As an example,
					trying to print a future object for debugging
					purpose will most of the time lead to a deadlock.
					Instead of displaying the corresponding string of a
					future object, you might consider displaying its
					hashCode.
				</para>
				</listitem>
				</itemizedlist>

		</section>

		<section xml:id="Asynchronouscallsindetails_71"><info><title>Asynchronous calls in details</title></info>


			<section xml:id="Thesetup_71"><info><title>The setup</title></info>


				<para>
					First, let us introduce the example we will use
					throughout this section. Let us say that some piece
					of code of a class (that we named
					<literal>Caller</literal>)
					calls the method
					<literal>foo()</literal>
					on an active instance of class
					<literal>Worker</literal>.
					This call is asynchronous and returns a future
					object of class
					<literal>Value</literal>.
					Then, possibly after having executed some other
					code, the same thread that issued the call calls
					the method
					<literal>bar()</literal>
					on the future object returned by the call to
					<literal>foo()</literal>.

				</para>
				<para>
					The code for the following example is:
				</para>

					<programlisting language="java"><textobject><textdata fileref="code_snippets/Caller_1.snip"/></textobject></programlisting>
			</section>

			<section xml:id="what_whould_have_happened_in_sequential_world"><info><title>What would have happened in a sequential world</title></info>

            <para>
               In a sequential world, the method in charge of the call would look like as follows:
            </para>
					<programlisting language="java"><textobject><textdata fileref="code_snippets/Caller_2.snip"/></textobject></programlisting>

				<para>
					In this single-threaded version,
					the thread executes the code
					of the caller object <literal>Caller</literal>
					up to the call of <literal>foo</literal>.
               Then, the code of
					<literal>foo()</literal>
					in class
					<literal>Worker</literal> is executed.
					After that, the thread comes back to the code of the calling method in
					object <literal>Caller</literal>
					up to the call to
					<literal>bar()</literal>.
				   Next, the code of
					<literal>bar()</literal>
					in class
					<literal>Value</literal> is executed
					and finally, the thread returns to the code of the calling method
					in class
					<literal>Caller</literal>
					until its end. The sequence diagram below summarizes
					this execution. You can notice how the single thread
					successively executes code of different methods in
					different classes.
				</para>

				<para>
					<figure xml:id="single_threaded_version"><info><title>Single-threaded version	of the program</title></info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/sequentialCall.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>
			</section>

			<section xml:id="Visualizingthegraphofactiveandpassiveobjects_71"><info><title>Visualizing the graph of active and passive objects</title></info>


				<para>
					Now, we will show how an active object handles the call for the code above.
					Instead of blocking on the execution of <literal>foo()</literal>, it will create a future
					and continue execution.
					Let us first get an idea of what the graph of
					objects at execution (the objects with their
					references to each other) looks like at three
					different moments of the execution:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Before calling
							<literal>foo()</literal>,
							 we have exactly the same setup as after
							the creation of the active instance of
							<literal>Worker</literal>: an
							instance of class
							<literal>Caller</literal>
							and an active instance of class
							<literal>Worker</literal>.
							As with all active objects, the instance of
							the class
							<literal>Worker</literal>
							is composed a
							<literal>Body</literal> with a request queue
							and the actual instance of
							<literal>Worker</literal>.
						</para>

		<para>
			<figure xml:id="Thecomponentsofanactiveobjectandof_71"><info><title>The components of an active object and of a referencing object</title></info>


				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/workerActiveObject.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
		</para>

					</listitem>

					<listitem>
						<para>
							After the asynchronous call of
							<literal>foo()</literal>,
							<literal>Caller</literal>
							now holds a reference onto a future object
							representing the not yet available result of
							the call. It is actually composed of a
							<literal>Stub_Value</literal>
							and a
							<literal>FutureProxy</literal>
							as shown on the figure below.
						</para>

						<para>
							<figure xml:id="components_of_future_before_the_result"><info><title>The components of a future object before the result is set</title></info>


								<mediaobject>
									<imageobject>
										<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/workerActiveObjectWithFuture.png" format="PNG"/>
									</imageobject>
								</mediaobject>
							</figure>
						</para>
					</listitem>

					<listitem>
						<para>
							Right after having executed
							<literal>foo()</literal>
							on the instance of
							<literal>Worker</literal>,
							the thread of the
							<literal>Body</literal>
							sets the result in the future.
                     For that, it gives
							<literal>FutureProxy</literal>
							a reference onto a
							<literal>Value</literal>
							(see figure below).
						</para>

						<para>
							<figure xml:id="components_of_a_future_object"><info><title>All components of a future object</title></info>


								<mediaobject>
									<imageobject>
										<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/workerActiveObjectWithUpdatedFuture.png" format="PNG"/>
									</imageobject>
								</mediaobject>
							</figure>
						</para>
					</listitem>
				</itemizedlist>
			</section>

			<section xml:id="SequenceDiagram_71"><info><title>Sequence Diagram</title></info>


				<para>
					The sequence of calls is more complex for the active object
					case.	We have now two
					threads: the thread that belongs to the subsystem of <literal>Caller</literal>
					and the one that belongs to
					the subsystem of <literal>Worker</literal>.
					We will call these the first and second threads.
			</para>

				<para>
					The first thread invokes
					<literal>foo()</literal>
					on an instance of
					<literal>Stub_Worker</literal>,
					which builds a
					<literal>MethodCall</literal>
					object and passes it to the
					<literal>BodyProxy</literal>
					as a parameter of the call to be
					<literal>reified</literal>.
					The proxy then checks the return type of the call
					(in this case
					<literal>Value</literal>)
					and generates a future object of type
					<literal>Value</literal>
					for representing the result of the method
					invocation. The future object is actually composed
					of a
					<literal>Stub_V</literal>
					and a
					<literal>FutureProxy</literal>.
					A reference onto this future object is set in the
					<literal>MethodCall</literal>
					object. This reference will be used to set the value
					after the call has been executed. When the
					<literal>MethodCall</literal>
					object is ready, it is passed as a parameter for a Request to the
					<literal>Body</literal>
					of the <literal>Worker</literal> active object. The
					<literal>Body</literal> simply
					appends this request to the queue of pending
					requests and returns immediately. The call to
					<literal>foo()</literal> issued by <literal>Caller</literal>
					returns a future object of type	<literal>Stub_Value</literal>,
					that is a subclass of
					<literal>Value</literal>.
				</para>

				<para>
					At some point, possibly after having served some
					other requests, the
					second thread
					(the active object's thread) picks up the previous request issued by
					the first thread. It then executes the embedded call by
					calling
					<literal>foo()</literal>
					on the instance of
					<literal>Worker</literal>
					with the actual parameters stored in the
					<literal>MethodCall</literal>
					object. As specified in its signature, this call
					returns an object of type
					<literal>Value</literal>. The second thread
					is responsible for setting this object in the
					future object (which is the reason why
					<literal>MethodCall</literal>
					objects hold a reference onto the future object
					created by the <literal>FutureProxy</literal>).
					The execution of the call is now over, and the
					second thread can select and serve another request from
					the queue.
				</para>

				<para>
					In the meantime, the
					first thread
					has continued executing the code of the calling
					method in class
					<literal>Caller</literal>.
					At some point, it calls
					<literal>bar()</literal>
					on the object of type
					<literal>Stub_Value</literal>
					that was returned by the call of
					<literal>foo()</literal>. This call is reified thanks to the
					<literal>Stub_Value </literal>and processed by the
					<literal>FutureProxy</literal>. If the object the
					 future represents is available
					(the second thread has already set it in the future object),
					the call is executed and returns a value to the calling code in
					<literal>Caller</literal>. The sequence diagram below presents the
					process graphically.

				</para>

				<para>
					<figure xml:id="Callflowwhenafutureissetbefore_71"><info><title>Call flow when a future is set before being used</title></info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/threadedCallWithFuture.png"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>

				<para>
					If the value in the future it is not available yet, the first thread is
					suspended in <literal>FutureProxy</literal>
					until the second thread sets the result in the
					future object (see figure below). This is called
					<literal>wait-by-necessity</literal>.
				</para>

				<para>
					<figure xml:id="Callflowwhenthefutureisnotset_71"><info><title>Call flow when the future is not set before being used (wait-by-necessity)</title></info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/threadedCallWithWaitForFuture.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
				</para>
			</section>
		</section>

		<section xml:id="FutureObjectCreation_commonerror"><info><title xml:id="GoodProActiveprogrammingpractices_71">Good ProActive programming practices</title></info>


			<para>
				There are few things to remember with active objects, futures, and
				asynchronous method calls, in order to avoid annoying
				debugging sessions:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">
							 A constructor with no-args
						</emphasis>
						needs to be used either for the
						Active Objects creation (if not present, an
						exception might be thrown) or Future creation
						for a method call (if not present, the method
						call is synchronous). Avoid placing
						initialization code in this constructor, as it
						may lead to unexpected behavior because this
						constructor is called for the stub creation.
					</para>
				</listitem>

				<listitem>
					<para>
						Make your classes implement
						<emphasis role="bold">Serializable</emphasis>
						interface since ProActive deals with objects
						that will be sent across networks.
					</para>
				</listitem>

				<listitem>
					<indexterm>
						<primary>Wrappers</primary>

						<secondary>Asynchronism</secondary>
					</indexterm>

					<para>
						Use
						<emphasis role="bold">wrappers</emphasis>
						instead of primitive types or final classes for
						methods result types. Otherwise, you will loose the
						asynchronism capabilities. For instance, if one
						of your object has a method whose signature looks like this:
					</para>

					<programlisting language="java">int giveSolution(parameter)</programlisting>

					<para>
						calling this method with ProActive is
						synchronous. To have asynchronous calls, use:
					</para>

					<programlisting language="java">IntWrapper giveSolution(parameter)</programlisting>

				<para>
						All wrappers are in the package:
						<literal>
							org.objectweb.proactive.core.util.wrapper
						</literal>
					</para>

					<para>
						ProActive provides several primitive type
						wrappers, with 2 versions of each, one
						<emphasis role="bold">mutable</emphasis>,
						and another	<emphasis role="bold">immutable</emphasis>.
					</para>

					<para>
						To make the call asynchronous, only the methods return types
						have to use wrappers. The parameters can use the regular
						Java types.
					</para>
				</listitem>

				<listitem>
					<para>
						Avoid
						to return <literal>null</literal> in Active Object methods:
						on the caller side the test

						<programlisting language="java">if(result_from_method == null)</programlisting>

						has no sense. <literal>Result_from_method</literal> is a
						couple Stub - FutureProxy as explained above, so
						even if the method returns <literal>null</literal>,
						result_from_method cannot be <literal>null</literal>:
					</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/Good_Practice_1.snip"/></textobject></programlisting>

					<para>On the caller side:</para>
			<programlisting language="java"><textobject><textdata fileref="code_snippets/Good_Practice_2.snip"/></textobject></programlisting>


					<para>
						This test is never true because
						either worker is equal to
						<literal>
							Stub--&gt;Proxy--&gt;null
						</literal>
						if the future is not available yet or if the method
						returns <literal>null</literal>, or worker is equal to
						<literal>
							Stub--&gt;Proxy--&gt;Object
						</literal>
						if the future is available.
						But <literal>worker</literal> is never <literal>null</literal>.
                  In our case, the method has returned null since worker's name is
                  <literal>Anonymous</literal> and the execution trace of the caller is
                  the following:
					</para>
               <screen>
                  === Started Active object:
                  org.objectweb.proactive.examples.documentation.classes.Worker on rmi://kisscool.inria.fr:6618/Node1346108379
                  worker is not null
                  Exception in thread "main" java.lang.NullPointerException
                     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                     at sun.reflect.NativeMethodAcccumentation.activeobjectconcepts.Caller.goodPractice(Caller.java:71)
                     at org.objectweb.proactive.examples.documentation.activeobjectconcepts.Caller.main(Caller.java:86)
               </screen>
               <para>
                  As you can see, <literal>worker</literal> is considered as not null and, as we call one of its method and since
                  it is actually null, we get a <literal>NullPointerException</literal>.
               </para>
				</listitem>
				<listitem>
				<para>
				While using synchronous calls within your code is discouraged, it happens that sometimes you cannot avoid using them. 
				To mimic the behaviour of a synchronous call on top of our asynchronous framework, synchronous calls are blocked within the ProActive Programming layer until the result is computed and the future filled with the result.
				If the future is not filled for any reason, the call is going to be blocked for ever and there is nothing you can do. To address this issue, it is possible to set a timeout for this kind of method call. 
				The property to modify is <code>proactive.future.synchrequest.timeout</code>. By default, the value is 0, meaning an unlimited timeout. When this value is set to a positive long value, this value is used as timeout value.
				When the timeout is reached, a <code>ProActiveTimeoutException</code> is thrown. To catch the exception, just enclosed the synchronous method call within a try/catch block and define the appropriate treatment in the catch block.     
				</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="Lightweightfailuredetection_71"><info><title>Lightweight failure detection</title></info>


			<para>
				Waiting for the update of a future in a ProActive
				application could freeze the application  if the node
				responsible for
				updating the future experiences a failure. To prevent this,
				ProActive has a comprehensive generic
				fault tolerance mechanism. However, it can be too expensive
				to checkpoint all the active objects, when fault detection
				is only needed for certain objects.
				<!-- //TODO AMBIGOUS ASK -->
			</para>

			<para>
				By default, ProActive continuously pings active objects
				awaited for updating futures. When such a ping fails,
				the associated awaited future is updated with a runtime
				exception. Accessing the future will throw
				an exception.
			</para>

			<programlisting language="java"><textobject><textdata fileref="code_snippets/Good_Practice_3.snip"/></textobject></programlisting>

			<para>
				The ping is started when the future is being awaited, but
				it is also possible to start it beforehand using the
				<literal>ProFuture.monitorFuture(java.lang.Object future)</literal> method.				
			</para>
		</section>
	</section>

	<section xml:id="AC"><info><title xml:id="AutomaticContinuationinProActive_71">Automatic Continuation in ProActive</title></info>


		<indexterm significance="preferred">
			<primary>Automatic Continuation</primary>
		</indexterm>


			<para>
				Automatic continuation is the propagation of a
				future outside the activity that has sent the
				corresponding request.
			</para>

			<para>
				Automatic continuations allows using
				non-updated futures in the normal program flow without
				blocking to wait for updating the result contained in the future.

				When the result is available on the object
				that originated the creation of the future, this object
				updates the result in all the objects to which it passed
				the future. If the objects passed the future further they
				will updated the value in the corresponding objects.
			</para>

		<section xml:id="SendingFutures_71"><info><title>Sending Futures</title></info>


					<para>
						An automatic continuation can occur either when sending a
						request (request parameter is or contains a future) or
                  when sending a reply (the
						result is or contains a future).
						Outgoing futures are registered in the
						<literal>FuturePool</literal>
						of the active object which sends the future. For instance,
                  In the example presented in the <xref linkend="IllustrationofanAutomaticContinuation_71"/>,
                  a <literal>FuturePool</literal> is created on the <literal>Caller</literal> side.
						This <literal>FuturePool</literal> is a pool of couples
                  &lt;Future, Destination&gt;
						and is filled in when the future is
						serialized. Every request or reply are
						serialized before being sent, and the future is
						part of the request or the reply.


						A thread
						<literal>Thread</literal>
						sending the message keeps in a static table (<literal>FuturePool.bodiesDestination</literal>)
						 a reference to the destination body. Hence,
						when a future
						<literal>Future</literal>
						is serialized by the same thread, this thread looks up in the
						static table the destination
						<literal>Destination</literal>
						registered for the thread
						<literal>Thread</literal>.
						 If it finds a destination for the future, the future notifies the
						<literal>FuturePool</literal>
						that it is going to leave, which in turn
						registers the &lt;Future, Destination&gt; as an automatic
						continuation.
					</para>

					<para>
						When the value	is available for the future, it is
						is propagated to all objects that received the
						future <literal>Future</literal>.
						This type of update is realized by a thread
						located in the	<literal>FuturePool</literal>.
					</para>
			</section>
			<section xml:id="ReceivingFutures_71"><info><title>Receiving Futures</title></info>


							<para>
						When a message containing a future is received by
						an active object  the active object registers the
						future in the
						<emphasis role="bold">FuturePool</emphasis>
						to be able to update it when the value will be
						available.
						<!-- TODO //Ambigous needs to be exapanded-->
						After the future is deserialized, it is
								registered in a static table
								<literal>
									FuturePool.incomingFutures</literal>.
							</para>

		</section>



		<section xml:id="IllustrationofanAutomaticContinuation_71"><info><title>Illustration of an Automatic Continuation</title></info>


			<indexterm>
				<primary>Automatic Continuation</primary>
			</indexterm>
						<para>
				To illustrate how automatic continuation takes place,  we will use three classes:
				<literal>Caller</literal>, <literal>Value</literal> and <literal>Worker</literal>. The
				 <literal>Caller</literal> and <literal>Value</literal> classes are used to instantiate passive
				 objects and the <literal>Worker</literal> class is used to instantiate an active object.
				 The <literal>Worker</literal> class has a <literal>foo()</literal> method and the
				 <literal>Value</literal> class has a <literal> bar(Value v, int nbYears)</literal> method.

			</para>

         <programlisting language="java"><textobject><textdata fileref="code_snippets/Continuation_1.snip"/></textobject></programlisting>

			<para>where</para>

         <programlisting language="java"><textobject><textdata fileref="code_snippets/Continuation_2.snip"/></textobject></programlisting>

			<para>and</para>

         <programlisting language="java"><textobject><textdata fileref="code_snippets/Continuation_3.snip"/></textobject></programlisting>


			<para>
			We will first call <literal>foo()</literal> on the worker. The call goes through the worker stub
			and the body proxy and it is placed in the queue of the body. We are using
			a passive object as an example, however the process would be similar if the
			caller was an active object or if the objects were all on the same machine. In
			those cases, the call
			will also go through the stub and proxy as described in the sequence diagrams above.
         The following pictures represent the continuation process. Note that in this diagram, the caller is named <literal>A</literal>
         and the value is named <literal>B</literal>.
			</para>
			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation1.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>
			<para>

				After sending the request, the thread of object <literal>A</literal> continues immediately
				(asynchronous call)
				and <literal>v1</literal> points to a future that has not been updated yet.
				</para>

			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation2.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>

			<para>Next, object <literal>A</literal> calls <literal>bar(v1, 1)</literal> on <literal>B</literal>.</para>
			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation3.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>
			<para>

				The call on <literal>B</literal> leads to the creation of another future
				to which <literal>v2</literal> will point to. Since <literal>v1</literal>
				has not been updated yet, there will be another future created on object
            <literal>B</literal>.
			</para>

			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation4.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>

			<para>
			At some point, the active object finishes executing <literal>foo()</literal>
			and the value of the future for <literal>v1</literal> will be updated by the
			<literal>Body</literal>.
			</para>

			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation5.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>
			<para>
			After the value
			<!-- //TODO synchronous or asych? --> on <literal>A</literal> is
			updated, <literal>A</literal> updates the value in the future on <literal>B</literal>.
			</para>


			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation6.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>

			<para>
				Once <literal>B</literal> has the value for the future, it will execute
				<literal>bar()</literal> with the received value and update the value
				<literal>v2</literal> in <literal>A</literal>.
			</para>

			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation7.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>

			<para>
				The final state is with all the future values updated.
			</para>
			<para>
				<informalfigure>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="images/png/automaticContinuation8.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</informalfigure>
			</para>
			<para>As seen above, as long as there is a future needed for a computation, it
			will be passed to the object doing the computation when it is not
			needed immediately. If the value is needed right away, the caller thread will
			block until the future is updated, just like in single threaded call.
			</para>
			<para>
			<!--  //TODO object responsabilities when  updating futures --></para>
		</section>
	</section>
</chapter>
